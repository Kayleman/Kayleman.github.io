{"meta":{"title":"Kayle's Blog","subtitle":"Never forget to say \"thanks\".","description":"Record my learning process and share it.","author":"Kayle Zhuang","url":"http://kayleman.github.io"},"pages":[{"title":"","date":"2017-06-24T08:24:40.000Z","updated":"2017-06-24T08:24:40.000Z","comments":true,"path":"404.html","permalink":"http://kayleman.github.io/404.html","excerpt":"","text":""},{"title":"About","date":"2017-06-24T04:59:38.000Z","updated":"2017-06-24T04:59:38.000Z","comments":true,"path":"about/index.html","permalink":"http://kayleman.github.io/about/index.html","excerpt":"","text":"昔日寒山问拾得曰：世间有人谤我、欺我、辱我、笑我、轻我、贱我、恶我、骗我、如何处治乎？ 拾得曰：只要忍他、让他、由他、避他、耐他、敬他、不要理他，再待几年你且看他。"},{"title":"tags","date":"2017-06-23T12:41:18.000Z","updated":"2017-06-23T12:41:18.000Z","comments":true,"path":"tags/index.html","permalink":"http://kayleman.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-06-23T12:41:01.000Z","updated":"2017-06-23T12:41:01.000Z","comments":true,"path":"categories/index.html","permalink":"http://kayleman.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring MVC执行流程及工作原理","slug":"Spring MVC执行流程及工作原理","date":"2018-07-24T02:47:34.000Z","updated":"2018-07-24T02:55:27.000Z","comments":true,"path":"2018/07/24/Spring MVC执行流程及工作原理/","link":"","permalink":"http://kayleman.github.io/2018/07/24/Spring MVC执行流程及工作原理/","excerpt":"前言本文用图文结合的方式介绍了Spring MVC执行流程及工作原理。","text":"前言本文用图文结合的方式介绍了Spring MVC执行流程及工作原理。 Spring MVC执行流程图： Spring MVC执行流程解释: 用户发送请求至前端控制器DispatcherServlet DispatcherServlet收到请求调用处理器映射器HandlerMapping。 处理器映射器根据请求url找到具体的处理器，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给DispatcherServlet。 DispatcherServlet根据处理器Handler获取处理器适配器HandlerAdapter执行HandlerAdapter处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作 执行处理器Handler(Controller，也叫页面控制器)。 Handler执行完成返回ModelAndView HandlerAdapter将Handler执行结果ModelAndView返回到DispatcherServlet DispatcherServlet将ModelAndView传给ViewReslover视图解析器 ViewReslover解析后返回具体View DispatcherServlet对View进行渲染视图（即将模型数据model填充至视图中）。 DispatcherServlet响应用户。 组件说明： DispatcherServlet：前端控制器。用户请求到达前端控制器，它就相当于MVC模式中的C，DispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，DispatcherServlet的存在降低了组件之间的耦合性,系统扩展性提高。由框架实现 HandlerMapping：处理器映射器。HandlerMapping负责根据用户请求的url找到Handler即处理器，Spring MVC提供了不同的映射器实现不同的映射方式，根据一定的规则去查找,例如：xml配置方式，实现接口方式，注解方式等。由框架实现 Handler：处理器。Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。 HandlAdapter：处理器适配器。通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。由框架实现。 ModelAndView是Spring MVC的封装对象，将Model和View封装在一起。 ViewResolver：视图解析器。ViewResolver负责将处理结果生成View视图，ViewResolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 View:是Spring MVC的封装对象，是一个接口, Spring MVC框架提供了很多的View视图类型，包括：jspview，pdfview,jstlView、freemarkerView、pdfView等。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。 参考https://www.jianshu.com/p/8a20c547e245","categories":[{"name":"备忘","slug":"备忘","permalink":"http://kayleman.github.io/categories/备忘/"}],"tags":[{"name":"python","slug":"python","permalink":"http://kayleman.github.io/tags/python/"},{"name":"Java","slug":"Java","permalink":"http://kayleman.github.io/tags/Java/"}]},{"title":"Java多线程学习","slug":"Java多线程学习","date":"2018-07-06T13:28:05.000Z","updated":"2018-07-13T06:06:23.000Z","comments":true,"path":"2018/07/06/Java多线程学习/","link":"","permalink":"http://kayleman.github.io/2018/07/06/Java多线程学习/","excerpt":"前言本文主要讲了Java中多线程的使用方法、线程同步、线程数据传递、线程状态及相应的一些线程函数用法、概述等。在这之前，首先让我们来了解下在操作系统中进程和线程的区别： 进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1~n个线程。（进程是资源分配的最小单位） 线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是CPU调度的最小单位） 线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。 多进程是指操作系统能同时运行多个任务（程序）。 多线程是指在同一程序中有多个顺序流在执行。 在Java中要想实现多线程，有两种手段，一种是继承Thread类，另外一种是实现Runable接口。(其实准确来讲，应该有三种，还有一种是实现Callable接口，并与Future、线程池结合使用。）","text":"前言本文主要讲了Java中多线程的使用方法、线程同步、线程数据传递、线程状态及相应的一些线程函数用法、概述等。在这之前，首先让我们来了解下在操作系统中进程和线程的区别： 进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1~n个线程。（进程是资源分配的最小单位） 线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是CPU调度的最小单位） 线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。 多进程是指操作系统能同时运行多个任务（程序）。 多线程是指在同一程序中有多个顺序流在执行。 在Java中要想实现多线程，有两种手段，一种是继承Thread类，另外一种是实现Runable接口。(其实准确来讲，应该有三种，还有一种是实现Callable接口，并与Future、线程池结合使用。） 一、扩展java.lang.Thread类这里继承Thread类的方法是比较常用的一种，如果说你只是想起一条线程。没有什么其它特殊的要求，那么可以使用Thread.（推荐使用Runable）。下面来看一个简单的实例: 12345678910111213141516171819202122232425262728package algorithm.thread_learn;class Thread_Demo1 extends Thread&#123; private String name; public Thread_Demo1(String name) &#123; this.name = name; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(name + &quot; Run:&quot; + i); try &#123; sleep((int) Math.random() * 10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;public class Thread_Demo1_Main &#123; public static void main(String[] args) &#123; Thread_Demo1 Th1 = new Thread_Demo1(&quot;A&quot;); Thread_Demo1 Th2 = new Thread_Demo1(&quot;B&quot;); Th1.start(); Th2.start(); &#125;&#125; 输出： 12345678910A Run:0B Run:0A Run:1B Run:1A Run:2B Run:2A Run:3B Run:3A Run:4B Run:4 再运行一下： 12345678910A Run:0B Run:0B Run:1A Run:1A Run:2B Run:2A Run:3B Run:3A Run:4B Run:4 说明： 程序启动运行main的时候，Java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用Thread_Demo1的两个对象的start方法，另外两个线程也启动了，这样，整个应用就在多线程下运行。 注意： start()方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行状态（Runnable），什么时候运行是由操作系统决定的。 从程序运行的结果可以发现，多线程程序是乱序执行的。因此，只有乱序执行的代码才有必要设计为多线程。 Thread.sleep()方法调用目的是不让当前线程独自霸占该进程所获取的CPU资源，以留出一定时间给其他线程执行的机会。 实际上所有的多线程代码执行顺序都是不确定的，每次执行的结果都是随机的。但是start方法重复调用的话，会出现java.lang.IllegalThreadStateException异常。 比如上面代码改写一下： 12345678public class Thread_Demo1_Main &#123; public static void main(String[] args) &#123; Thread_Demo1 Th1 = new Thread_Demo1(&quot;A&quot;); Thread_Demo1 Th2 = Th1; Th1.start(); Th2.start(); &#125;&#125; 输出： 123Exception in thread &quot;main&quot; java.lang.IllegalThreadStateException at java.lang.Thread.start(Thread.java:705) at algorithm.thread_learn.Thread_Demo1_Main.main(Thread_Demo1_Main.java:26) 二、实现java.lang.Runnable接口采用Runnable也是非常常见的一种，我们只需要重写run方法即可。下面也来看个实例。 12345678910111213141516171819202122232425package algorithm.thread_learn;class Thread_Demo2 implements Runnable &#123; private String name; public Thread_Demo2(String name) &#123; this.name = name; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(name + &quot; Run:&quot; + i); try &#123; Thread.sleep((int) Math.random() *10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;public class Thread_Demo2_Main &#123; public static void main(String[] args) &#123; new Thread(new Thread_Demo2(&quot;C&quot;)).start(); new Thread(new Thread_Demo2(&quot;D&quot;)).start(); &#125;&#125; 输出： 12345678910C Run:0D Run:0D Run:1C Run:1D Run:2C Run:2D Run:3C Run:3D Run:4C Run:4 说明：Thread2类通过实现Runnable接口，使得该类有了多线程类的特征。run（）方法是多线程程序的一个约定。所有的多线程代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。 在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread对象的start()方法来运行多线程代码。 实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是扩展Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。 三、Thread和Runnable的区别如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。 总结： 实现Runnable接口比继承Thread类所具有的优势： 适合多个相同的程序代码的线程去处理同一个资源 可以避免Java中的单继承的限制 增加程序的健壮性，代码可以被多个线程共享，代码和数据独立 线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类 提醒：main方法其实也是一个线程。在Java中所有的线程都是同时启动的，至于什么时候，哪个先执行，完全看谁先得到CPU的资源。 在Java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用Java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM实际上就是在操作系统中启动了一个进程。 四、线程状态转换下面的这个图非常重要！看懂了这个图，对于多线程的理解将会更加深刻！ 新建状态（New）：新创建了一个线程对象。 就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。 运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。 阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种： 等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁) 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。 其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意:sleep不会释放持有的锁） 死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。 五、线程调度1.调整线程优先级：Java线程有优先级，优先级高的线程会获得较多的运行机会。 Java线程的优先级用整数表示，取值范围是1~10，Thread类有以下三个静态常量： 123456static int MAX_PRIORITY 线程可以具有的最高优先级，取值为10。static int MIN_PRIORITY 线程可以具有的最低优先级，取值为1。static int NORM_PRIORITY 分配给线程的默认优先级，取值为5。 Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。 每个线程都有默认的优先级。主线程的默认优先级为Thread.NORM_PRIORITY。 线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级。 JVM提供了10个线程优先级，但与常见的操作系统都不能很好的映射。如果希望程序能移植到各个操作系统中，应该仅仅使用Thread类有以下三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式。 2.线程睡眠：Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。 3.线程等待：Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。 4.线程让步：Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。 5.线程加入：join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。 6.线程唤醒：Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个wait方法，在对象的监视器上等待。直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如:唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。 注意:Thread中suspend()和resume()两个方法在JDK1.5中已经废除，不再介绍。因为有死锁倾向。 六、常用函数说明1.sleep(long millis): 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行） 2.join(): 指等待t线程终止。 使用方式: join是Thread类的一个方法，启动线程后直接调用，即join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。 1Thread t = new AThread(); t.start(); t.join(); 为什么要用join()方法? 在很多情况下，主线程生成并启动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。 不加join例子： 12345678910111213141516171819202122232425262728293031323334package algorithm.thread_learn;class Thread_Demo3 extends Thread &#123; private String name; public Thread_Demo3(String name) &#123; super(name); this.name = name; &#125; public void run() &#123; System.out.println(Thread.currentThread().getName() + &quot; thread start run!&quot;); for (int i = 0; i &lt; 5; i++) &#123; System.out.println(&quot;son thread &quot; + name + &quot; run: &quot; + i); try &#123; sleep((int)Math.random() * 10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName() + &quot; thread end run!&quot;); &#125;&#125;//not use join()public class Thread_Demo3_Main &#123; public static void main(String [] args) &#123; System.out.println(Thread.currentThread().getName() + &quot; thread start run!&quot;); Thread_Demo3 Th1 = new Thread_Demo3(&quot;A&quot;); Thread_Demo3 Th2 = new Thread_Demo3(&quot;B&quot;); Th1.start(); Th2.start(); System.out.println(Thread.currentThread().getName() + &quot; thread end run!&quot;); &#125;&#125; 输出： 12345678910111213141516main thread start run!A thread start run!main thread end run!B thread start run!son thread A run: 0son thread B run: 0son thread A run: 1son thread B run: 1son thread A run: 2son thread B run: 2son thread A run: 3son thread B run: 3son thread A run: 4son thread B run: 4A thread end run!B thread end run! 发现主线程比子线程早结束。 加join： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package algorithm.thread_learn;class Thread_Demo3 extends Thread &#123; private String name; public Thread_Demo3(String name) &#123; super(name); this.name = name; &#125; public void run() &#123; System.out.println(Thread.currentThread().getName() + &quot; thread start run!&quot;); for (int i = 0; i &lt; 5; i++) &#123; System.out.println(&quot;son thread &quot; + name + &quot; run: &quot; + i); try &#123; sleep((int)Math.random() * 10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName() + &quot; thread end run!&quot;); &#125;&#125;//use join()public class Thread_Demo3_Main &#123; public static void main(String [] args) &#123; System.out.println(Thread.currentThread().getName() + &quot; thread start run!&quot;); Thread_Demo3 Th1 = new Thread_Demo3(&quot;A&quot;); Thread_Demo3 Th2 = new Thread_Demo3(&quot;B&quot;); Th1.start(); Th2.start(); try &#123; Th1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; try &#123; Th2.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot; thread end run!&quot;); &#125;&#125; 输出： 12345678910111213141516main thread start run!A thread start run!B thread start run!son thread B run: 0son thread A run: 0son thread A run: 1son thread B run: 1son thread A run: 2son thread B run: 2son thread A run: 3son thread B run: 3son thread A run: 4son thread B run: 4A thread end run!B thread end run!main thread end run! 主线程一定会等子线程都结束了才结束。 3.yield(): 暂停当前正在执行的线程对象，并执行其他线程。 Thread.yield()方法作用是：暂停当前正在执行的线程对象，并执行其他线程。 yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。 结论：yield()从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。可看上面的图。 例子： 123456789101112131415161718192021222324252627package algorithm.thread_learn;class Thread_Demo4 extends Thread &#123; public Thread_Demo4(String name) &#123; super(name); &#125; @Override public void run()&#123; for (int i = 0; i &lt; 50; i++) &#123; System.out.println(&quot;&quot; + this.getName() + &quot;-------&quot; + i); //while i == 30 , this thread will fall back CPU to free if(i == 30) &#123; this.yield(); &#125; &#125; &#125;&#125;public class Thread_Demo4_Main &#123; public static void main(String[] args) &#123; Thread_Demo4 Th1 = new Thread_Demo4(&quot;A&quot;); Thread_Demo4 Th2 = new Thread_Demo4(&quot;B&quot;); Th1.start(); Th2.start(); &#125;&#125; 输出： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100B-------0B-------1B-------2A-------0B-------3A-------1B-------4A-------2B-------5B-------6A-------3A-------4A-------5A-------6A-------7A-------8B-------7A-------9B-------8A-------10A-------11B-------9B-------10B-------11B-------12B-------13B-------14B-------15B-------16B-------17B-------18B-------19B-------20B-------21B-------22B-------23B-------24B-------25B-------26B-------27B-------28B-------29B-------30A-------12A-------13A-------14A-------15A-------16A-------17A-------18A-------19A-------20A-------21A-------22A-------23A-------24A-------25A-------26A-------27A-------28A-------29A-------30B-------31B-------32B-------33B-------34B-------35B-------36B-------37B-------38B-------39B-------40B-------41B-------42B-------43B-------44B-------45B-------46B-------47B-------48B-------49A-------31A-------32A-------33A-------34A-------35A-------36A-------37A-------38A-------39A-------40A-------41A-------42A-------43A-------44A-------45A-------46A-------47A-------48A-------49 可以看到当A、B在运行到30的时候，就会把CPU让出来，然后进行抢夺，上面的结果是B先运行到30，然后让出，B自己没抢到，被A抢到，A运行到30又让出，被B抢走。 sleep()和yield()的区别： sleep()使当前线程进入停滞状态，所以执行sleep()的线程在指定的时间内肯定不会被执行；yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。 sleep方法使当前运行中的线程睡眼一段时间，进入不可运行状态，这段时间的长短是由程序设定的，yield方法使当前线程让出CPU占有权，但让出的时间是不可设定的。实际上，yield()方法对应了如下操作：先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把CPU的占有权交给此线程，否则，继续运行原来的线程。所以yield()方法称为“退让”，它把运行机会让给了同等优先级的其他线程。 另外，sleep方法允许较低优先级的线程获得运行机会，但yield()方法执行时，当前线程仍处在可运行状态，所以，不可能让出较低优先级的线程些时获得CPU占有权。在一个运行系统中，如果较高优先级的线程没有调用sleep方法，又没有受到I\\O阻塞，那么，较低优先级线程只能等待所有较高优先级的线程运行结束，才有机会运行。 4.setPriority(): 更改线程的优先级。 123MIN_PRIORITY = 1NORM_PRIORITY = 5MAX_PRIORITY = 10 用法： 1234Thread_Demo Th1 = new Thread_Demo(&quot;t1&quot;);Thread_Demo Th2 = new Thread_Demo(&quot;t2&quot;);Th1.setPriority(Thread.MAX_PRIORITY);Th2.setPriority(Thread.MIN_PRIORITY); 5.interrupt(): 不要以为它是中断某个线程！它只是线线程发送一个中断信号，让线程在无限等待时（如死锁时）能抛出抛出，从而结束线程，但是如果你吃掉了这个异常，那么这个线程还是不会中断的！ 6.wait(): Obj.wait()，与Obj.notify()必须要与synchronized(Obj)一起使用，也就是wait,与notify是针对已经获取了Obj锁进行操作，从语法角度来说就是Obj.wait(),Obj.notify必须在synchronized(Obj){…}语句块内。 从功能上来说wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行。相应的notify()就是对对象锁的唤醒操作。 但有一点需要注意的是notify()调用后，并不是马上就释放对象锁的，而是在相应的synchronized(){}语句块执行结束，自动释放锁后，JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。这样就提供了在线程间同步、唤醒的操作。 Thread.sleep()与Object.wait()二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制。 单单在概念上理解清楚了还不够，需要在实际的例子中进行测试才能更好的理解。对Object.wait()，Object.notify()的应用最经典的例子，应该是三线程打印ABC的问题了吧，这是一道比较经典的面试题，题目要求如下： 建立三个线程，A线程打印10次A，B线程打印10次B,C线程打印10次C，要求线程同时运行，交替打印10次ABC。这个问题用Object的wait()，notify()就可以很方便的解决。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package algorithm.thread_learn;//wait()import sword_refers_to_offer.TreeNode;import java.security.PrivateKey;class Thread_Demo5 implements Runnable &#123; private String name; private Object prev; private Object self; public Thread_Demo5(String name, Object prev, Object self) &#123; this.name = name; this.prev = prev; this.self = self; &#125; @Override public void run() &#123; int count = 10; while (count &gt; 0) &#123; synchronized (prev) &#123; synchronized (self) &#123; System.out.print(name); count--; self.notify(); &#125; try &#123; prev.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;public class Thread_Demo5_Main &#123; public static void main(String[] args) throws Exception &#123; Object a = new Object(); Object b = new Object(); Object c = new Object(); Thread_Demo5 print_a = new Thread_Demo5(&quot;A&quot;, c, a); Thread_Demo5 print_b = new Thread_Demo5(&quot;B&quot;, a, b); Thread_Demo5 print_c = new Thread_Demo5(&quot;C&quot;, b, c); new Thread(print_a).start(); Thread.sleep(100); // make sure output ABC new Thread(print_b).start(); Thread.sleep(100); new Thread(print_c).start(); Thread.sleep(100); &#125;&#125; 输出： 1ABCABCABCABCABCABCABCABCABCABC 先来解释一下其整体思路，从大的方向上来讲，该问题为三线程间的同步唤醒操作，主要的目的就是ThreadA-&gt;ThreadB-&gt;ThreadC-&gt;ThreadA循环执行三个线程。 为了控制线程执行的顺序，那么就必须要确定唤醒、等待的顺序，所以每一个线程必须同时持有两个对象锁，才能继续执行。一个对象锁是prev，就是前一个线程所持有的对象锁。还有一个就是自身对象锁。 主要的思想就是，为了控制执行的顺序，必须要先持有prev锁，也就前一个线程要释放自身对象锁，再去申请自身对象锁，两者兼备时打印，之后首先调用self.notify()释放自身对象锁，唤醒下一个等待线程，再调用prev.wait()释放prev对象锁，终止当前线程，等待循环结束后再次被唤醒。 运行上述代码，可以发现三个线程循环打印ABC，共10次。程序运行的主要过程就是A线程最先运行，持有C,A对象锁，后释放A,C锁，唤醒B。线程B等待A锁，再申请B锁，后打印B，再释放B，A锁，唤醒C，线程C等待B锁，再申请C锁，后打印C，再释放C,B锁，唤醒A。 看起来似乎没什么问题，但如果仔细想一下，就会发现有问题，就是初始条件，三个线程按照A,B,C的顺序来启动，按照前面的思考，A唤醒B，B唤醒C，C再唤醒A。但是这种假设依赖于JVM中线程调度、执行的顺序。 wait和sleep区别: 共同点： 他们都是在多线程的环境下，都可以在程序的调用处阻塞指定的毫秒数，并返回。 wait()和sleep()都可以通过interrupt()方法 打断线程的暂停状态 ，从而使线程立刻抛出InterruptedException。 如果线程A希望立即结束线程B，则可以对线程B对应的Thread实例调用interrupt方法。如果此刻线程B正在wait/sleep /join，则线程B会立刻抛出InterruptedException，在catch() {} 中直接return即可安全地结束线程。 需要注意的是，InterruptedException是线程自己从内部抛出的，并不是interrupt()方法抛出的。对某一线程调用 interrupt()时，如果该线程正在执行普通的代码，那么该线程根本就不会抛出InterruptedException。但是，一旦该线程进入到 wait()/sleep()/join()后，就会立刻抛出InterruptedException 。 不同点： Thread类的方法：sleep(),yield()等Object的方法：wait()和notify()等 每个对象都有一个锁来控制同步访问。Synchronized关键字可以和对象的锁交互，来实现线程的同步。 sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。 wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用 所以sleep()和wait()方法的最大区别是： sleep()睡眠时，保持对象锁，仍然占有该锁； 而wait()睡眠时，释放对象锁。 但是wait()和sleep()都可以通过interrupt()方法打断线程的暂停状态，从而使线程立刻抛出InterruptedException（但不建议使用该方法）。 sleep（）方法: sleep()使当前线程进入停滞状态（阻塞当前线程），让出CUP的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会; sleep()是Thread类的Static(静态)的方法；因此他不能改变对象的机锁，所以当在一个Synchronized块中调用Sleep()方法是，线程虽然休眠了，但是对象的机锁并木有被释放，其他线程无法访问这个对象（即使睡着也持有对象锁）。 在sleep()休眠时间期满后，该线程不一定会立即执行，这是因为其它线程可能正在运行而且没有被调度为放弃执行，除非此线程具有更高的优先级。 wait（）方法: wait()方法是Object类里的方法；当一个线程执行到wait()方法时，它就进入到一个和该对象相关的等待池中，同时失去（释放）了对象的机锁（暂时失去机锁，wait(long timeout)超时时间到后还需要返还对象锁）；其他线程可以访问； wait()使用notify或者notifyAlll或者指定睡眠时间来唤醒当前等待池中的线程。 wiat()必须放在synchronized block中，否则会在program runtime时扔出”java.lang.IllegalMonitorStateException“异常。 七、常见线程名词解释主线程：JVM调用程序main()所产生的线程。 当前线程：这个是容易混淆的概念。一般指通过Thread.currentThread()来获取的进程。 后台线程：指为其他线程提供服务的线程，也称为守护线程。JVM的垃圾回收线程就是一个后台线程。用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束 前台线程：是指接受后台线程服务的线程，其实前台后台线程是联系在一起，就像傀儡和幕后操纵者一样的关系。傀儡是前台线程、幕后操纵者是后台线程。由前台线程创建的线程默认也是前台线程。可以通过isDaemon()和setDaemon()方法来判断和设置一个线程是否为后台线程。 线程类的一些常用方法： sleep(): 强迫一个线程睡眠Ｎ毫秒。 isAlive(): 判断一个线程是否存活。 join(): 等待线程终止。 activeCount(): 程序中活跃的线程数。 enumerate(): 枚举程序中的线程。 currentThread(): 得到当前线程。 isDaemon(): 一个线程是否为守护线程。 setDaemon(): 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束) setName(): 为线程设置一个名称。 wait(): 强迫一个线程等待。 notify(): 通知一个线程继续运行。 setPriority(): 设置一个线程的优先级。 八、线程同步1、synchronized关键字的作用域有二种： 是某个对象实例内，synchronized aMethod(){}可以防止多个线程同时访问这个对象的synchronized方法（如果一个对象有多个synchronized方法，只要一个线程访问了其中的一个synchronized方法，其它线程不能同时访问这个对象中任何一个synchronized方法）。这时，不同的对象实例的synchronized方法是不相干扰的。也就是说，其它线程照样可以同时访问相同类的另一个对象实例中的synchronized方法； 是某个类的范围，synchronized static aStaticMethod{}防止多个线程同时访问这个类中的synchronized static 方法。它可以对类的所有对象实例起作用。 2、除了方法前用synchronized关键字，synchronized关键字还可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。用法是: synchronized(this){区块}，它的作用域是当前对象； 3、synchronized关键字是不能继承的，也就是说，基类的方法synchronized f(){} 在继承类中并不自动是synchronized f(){}，而是变成了f(){}。继承类需要你显式的指定它的某个方法为synchronized方法； Java对多线程的支持与同步机制深受大家的喜爱，似乎看起来使用了synchronized关键字就可以轻松地解决多线程共享数据同步问题。到底如何？――还得对synchronized关键字的作用进行深入了解才可定论。 总的说来，synchronized关键字可以作为函数的修饰符，也可作为函数内的语句，也就是平时说的同步方法和同步语句块。如果再细的分类，synchronized可作用于instance变量、object reference（对象引用）、static函数和class literals(类名称字面常量)身上。 在进一步阐述之前，需要明确几点： A．无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象，而不是把一段代码或函数当作锁――而且同步方法很可能还会被其他线程的对象访问。 B．每个对象只有一个锁（lock）与之相关联。 C．实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。 接着来讨论synchronized用到不同地方对代码产生的影响： 假设P1、P2是同一个类的不同对象，这个类中定义了以下几种情况的同步块或同步方法，P1、P2就都可以调用它们。 1.把synchronized当作函数修饰符时，示例代码如下：123public synchronized void methodAAA() &#123;//…&#125; 这也就是同步方法，那这时synchronized锁定的是哪个对象呢？它锁定的是调用这个同步方法对象。也就是说，当一个对象P1在不同的线程中执行这个同步方法时，它们之间会形成互斥，达到同步的效果。但是这个对象所属的Class所产生的另一对象P2却可以任意调用这个被加了synchronized关键字的方法。 上边的示例代码等同于如下代码： 12345public void methodAAA() &#123;synchronized (this)//(1) &#123; //… &#125;&#125; (1)处的this指的是什么呢？它指的就是调用这个方法的对象，如P1。可见同步方法实质是将synchronized作用于object reference。――那个拿到了P1对象锁的线程，才可以调用P1的同步方法，而对P2而言，P1这个锁与它毫不相干，程序也可能在这种情形下摆脱同步机制的控制，造成数据混乱： 2.同步块，示例代码如下：12345public void method3(SomeObject so) &#123; synchronized(so) &#123; //… &#125;&#125; 这时，锁就是so这个对象，谁拿到这个锁谁就可以运行它所控制的那段代码。当有一个明确的对象作为锁时，就可以这样写程序，但当没有明确的对象作为锁，只是想让一段代码同步时，可以创建一个特殊的instance变量（它得是一个对象）来充当锁： 12345678class Foo implements Runnable &#123; private byte[] lock = new byte[0]; // 特殊的instance变量 public void methodA() &#123; synchronized(lock) &#123; //… &#125; &#125; //…..&#125; 注：零长度的byte数组对象创建起来将比任何对象都经济――查看编译后的字节码：生成零长度的byte[]对象只需3条操作码，而Object lock = new Object()则需要7行操作码。 3.将synchronized作用于static函数，示例代码如下：123456789class Foo &#123; // 同步的static 函数 public synchronized static void methodAAA() &#123; //…. &#125; public void methodBBB() &#123; synchronized(Foo.class) // class literal(类名称字面常量) &#125;&#125; 代码中的methodBBB()方法是把class literal作为锁的情况，它和同步的static函数产生的效果是一样的，取得的锁很特别，是当前调用这个方法的对象所属的类（Class，而不再是由这个Class产生的某个具体对象了）。 记得在《Effective Java》一书中看到过将 Foo.class和 P1.getClass()用于作同步锁还不一样，不能用P1.getClass()来达到锁这个Class的目的。P1指的是由Foo类产生的对象。 可以推断：如果一个类中定义了一个synchronized的static函数A，也定义了一个synchronized 的instance函数B，那么这个类的同一对象Obj在多线程中分别访问A和B两个方法时，不会构成同步，因为它们的锁都不一样。A方法的锁是Obj这个对象，而B的锁是Obj所属的那个Class。 总结一下： 线程同步的目的是为了保护多个线程反问一个资源时对资源的破坏。 线程同步方法是通过锁来实现，每个对象都有切仅有一个锁，这个锁与一个特定的对象关联，线程一旦获取了对象锁，其他访问该对象的线程就无法再访问该对象的其他非同步方法 对于静态同步方法，锁是针对这个类的，锁对象是该类的Class对象。静态和非静态方法的锁互不干预。一个线程获得锁，当在一个同步方法中访问另外对象上的同步方法时，会获取这两个对象锁。 对于同步，要时刻清醒在哪个对象上同步，这是关键。 编写线程安全的类，需要时刻注意对多个线程竞争访问资源的逻辑和安全做出正确的判断，对“原子”操作做出分析，并保证原子操作期间别的线程无法访问竞争资源。 当多个线程等待一个对象锁时，没有获取到锁的线程将发生阻塞。 死锁是线程间相互等待锁锁造成的，在实际中发生的概率非常的小。真让你写个死锁程序，不一定好使，呵呵。但是，一旦程序发生死锁，程序将死掉。 九、线程数据传递在传统的同步开发模式下，当我们调用一个函数时，通过这个函数的参数将数据传入，并通过这个函数的返回值来返回最终的计算结果。但在多线程的异步开发模式下，数据的传递和返回和同步开发模式有很大的区别。由于线程的运行和结束是不可预料的，因此，在传递和返回数据时就无法象函数一样通过函数参数和return语句来返回数据。 1.通过构造方法传递数据在创建线程时，必须要建立一个Thread类的或其子类的实例。因此，我们不难想到在调用start方法之前通过线程类的构造方法将数据传入线程。并将传入的数据使用类变量保存起来，以便线程使用(其实就是在run方法中使用)。下面的代码演示了如何通过构造方法来传递数据： 12345678910111213141516package algorithm.thread_learn;public class Thread_Demo6_Main extends Thread&#123; private String name; public Thread_Demo6_Main(String name) &#123; this.name = name; &#125; public void run() &#123; System.out.println(&quot;hello &quot; + name); &#125; public static void main(String[] args) &#123; Thread Th = new Thread_Demo6_Main(&quot;world&quot;); Th.start(); &#125;&#125; 由于这种方法是在创建线程对象的同时传递数据的，因此，在线程运行之前这些数据就就已经到位了，这样就不会造成数据在线程运行后才传入的现象。如果要传递更复杂的数据，可以使用集合、类等数据结构。 使用构造方法来传递数据虽然比较安全，但如果要传递的数据比较多时，就会造成很多不便。由于Java没有默认参数，要想实现类似默认参数的效果，就得使用重载，这样不但使构造方法本身过于复杂，又会使构造方法在数量上大增。因此，要想避免这种情况，就得通过类方法或类变量来传递数据。 2.通过变量和方法传递数据向对象中传入数据一般有两次机会，第一次机会是在建立对象时通过构造方法将数据传入，另外一次机会就是在类中定义一系列的public的方法或变量（也可称之为字段）。然后在建立完对象后，通过对象实例逐个赋值。下面的代码是对Thread_Demo6_Main类的改版，使用了一个setName方法来设置name变量： 12345678910111213141516171819package algorithm.thread_learn;public class Thread_Demo7_Main implements Runnable &#123; private String name; public void setName(String name) &#123; this.name = name; &#125; public void run() &#123; System.out.println(&quot;hello &quot; + name); &#125; public static void main(String[] args) &#123; Thread_Demo7_Main Th1 = new Thread_Demo7_Main(); Th1.setName(&quot;world&quot;); Thread Th2 = new Thread(Th1); Th2.start(); &#125;&#125; 3.通过回调函数传递数据上面讨论的两种向线程中传递数据的方法是最常用的。但这两种方法都是main方法中主动将数据传入线程类的。这对于线程来说，是被动接收这些数据的。然而，在有些应用中需要在线程运行的过程中动态地获取数据，如在下面代码的run方法中产生了3个随机数，然后通过Work类的process方法求这三个随机数的和，并通过Data类的value将结果返回。从这个例子可以看出，在返回value之前，必须要得到三个随机数。也就是说，这个value是无法事先就传入线程类的。 12345678910111213141516171819202122232425262728293031323334package algorithm.thread_learn;class Data &#123; public int value = 0;&#125;class Work &#123; public void process(Data data, int... numbers) &#123; //...表示不定长参数 for (int n: numbers) &#123; data.value += n; &#125; &#125;&#125;public class Thread_Demo8_Main extends Thread&#123; private Work work; public Thread_Demo8_Main(Work work) &#123; this.work = work; &#125; public void run() &#123; java.util.Random random = new java.util.Random(); Data data = new Data(); int n1 = random.nextInt(1000); int n2 = random.nextInt(2000); int n3 = random.nextInt(3000); work.process(data, n1, n2, n3);//回调函数 System.out.println(String.valueOf(n1) + &quot;+&quot; + String.valueOf(n2) + &quot;+&quot; + String.valueOf(n3) + &quot;=&quot; + data.value); &#125; public static void main(String[] args) &#123; Thread Th = new Thread_Demo8_Main(new Work()); Th.start(); &#125;&#125;","categories":[{"name":"理解","slug":"理解","permalink":"http://kayleman.github.io/categories/理解/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kayleman.github.io/tags/Java/"}]},{"title":"理解TCP三次握手与四次挥手","slug":"理解TCP三次握手与四次挥手","date":"2018-06-28T13:34:34.000Z","updated":"2018-06-28T16:00:56.000Z","comments":true,"path":"2018/06/28/理解TCP三次握手与四次挥手/","link":"","permalink":"http://kayleman.github.io/2018/06/28/理解TCP三次握手与四次挥手/","excerpt":"前言TCP三次握手和四次挥手的问题在是最基础的问题之一。本文尝试使用动画来对这个知识点进行讲解，期望可以更加简单地地理解TCP交互的本质。","text":"前言TCP三次握手和四次挥手的问题在是最基础的问题之一。本文尝试使用动画来对这个知识点进行讲解，期望可以更加简单地地理解TCP交互的本质。 一、TCP 三次握手TCP三次握手就好比两个人在街上隔着50米看见了对方，但是因为雾霾等原因不能100%确认，所以要通过招手的方式相互确定对方是否认识自己。 张三首先向李四招手(syn)，李四看到张三向自己招手后，向对方点了点头挤出了一个微笑(ack)。张三看到李四微笑后确认了李四成功辨认出了自己(进入estalished状态)。 但是李四还有点狐疑，向四周看了一看，有没有可能张三是在看别人呢，他也需要确认一下。所以李四也向张三招了招手(syn)，张三看到李四向自己招手后知道对方是在寻求自己的确认，于是也点了点头挤出了微笑(ack)，李四看到对方的微笑后确认了张三就是在向自己打招呼(进入established状态)。 于是两人加快步伐，走到了一起，相互拥抱。 我们看到这个过程中一共是四个动作，张三招手–&gt;李四点头微笑–&gt;李四招手–&gt;张三点头微笑。其中李四连续进行了2个动作，先是点头微笑(回复对方)，然后再次招手(寻求确认)，实际上可以将这两个动作合一，招手的同时点头和微笑(syn+ack)。于是四个动作就简化成了三个动作，张三招手–&gt;李四点头微笑并招手–&gt;张三点头微笑。这就是三次握手的本质，中间的一次动作是两个动作的合并。 我们看到有两个中间状态，syn_sent和syn_rcvd，这两个状态叫着「半打开」状态，就是向对方招手了，但是还没来得及看到对方的点头微笑。syn_sent是主动打开方的「半打开」状态，syn_rcvd是被动打开方的「半打开」状态。客户端是主动打开方，服务器是被动打开方。 syn_sent: syn package has been sent syn_rcvd: syn package has been received 二、TCP 数据传输TCP 数据传输就是两个人隔空对话，差了一点距离，所以需要对方反复确认听见了自己的话。 张三喊了一句话(data)，李四听见了之后要向张三回复自己听见了(ack)。 如果张三喊了一句，半天没听到李四回复，张三就认为自己的话被大风吹走了，李四没听见，所以需要重新喊话，这就是「tcp重传」。 也有可能是李四听到了张三的话，但是李四向张三的回复被大风吹走了，以至于张三没听见李四的回复。张三并不能判断究竟是自己的话被大风吹走了还是李四的回复被大风吹走了，张三也不用管，重传一下就是。 既然会重传，李四就有可能同一句话听见了两次，这就是「去重」。「重传」和「去重」工作操作系统的网络内核模块都已经帮我们处理好了，用户层是不用关心的。 张三可以向李四喊话，同样李四也可以向张三喊话，因为tcp链接是「双工的」，双方都可以主动发起数据传输。不过无论是哪方喊话，都需要收到对方的确认才能认为对方收到了自己的喊话。 张三可能是个高射炮，一说连说了八句话，这时候李四可以不用一句一句回复，而是连续听了这八句话之后，一起向对方回复说前面你说的八句话我都听见了，这就是批量ack。但是张三也不能一次性说了太多话，李四的脑子短时间可能无法消化太多，两人之间需要有协商好的合适的发送和接受速率，这个就是「TCP窗口大小」。 网络环境的数据交互同人类之间的对话还要复杂一些，它存在数据包乱序的现象。同一个来源发出来的不同数据包在「网际路由」上可能会走过不同的路径，最终达到同一个地方时，顺序就不一样了。操作系统的网络内核模块会负责对数据包进行排序，到用户层时顺序就已经完全一致了。 三、TCP 四次挥手TCP断开链接的过程和建立链接的过程比较类似，只不过中间的两部并不总是会合成一步走，所以它分成了4个动作，张三挥手(fin)–&gt;李四伤感地微笑(ack)–&gt;李四挥手(fin)–&gt;张三伤感地微笑(ack)。 之所以中间的两个动作没有合并，是因为tcp存在「半关闭」状态，也就是单向关闭。张三已经挥了手，可是人还没有走，只是不再说话，但是耳朵还是可以继续听，李四呢继续喊话。等待李四累了，也不再说话了，超张三挥了挥手，张三伤感地微笑了一下，才彻底结束了。 上面有一个非常特殊的状态time_wait，它是主动关闭的一方在回复完对方的挥手后进入的一个长期状态，这个状态标准的持续时间是4分钟，4分钟后才会进入到closed状态，释放套接字资源。不过在具体实现上这个时间是可以调整的。 它就好比主动分手方要承担的责任，是你提出的要分手，你得付出代价。这个后果就是持续4分钟的time_wait状态，不能释放套接字资源(端口)，就好比守寡期，这段时间内套接字资源(端口)不得回收利用。 它的作用是重传最后一个ack报文，确保对方可以收到。因为如果对方没有收到ack的话，会重传fin报文，处于time_wait状态的套接字会立即向对方重发ack报文。 同时在这段时间内，该链接在对话期间于网际路由上产生的残留报文(因为路径过于崎岖，数据报文走的时间太长，重传的报文都收到了，原始报文还在路上)传过来时，都会被立即丢弃掉。4分钟的时间足以使得这些残留报文彻底消逝。不然当新的端口被重复利用时，这些残留报文可能会干扰新的链接。 4分钟就是2个MSL，每个MSL是2分钟。MSL就是maximium segment lifetime——最长报文寿命。这个时间是由官方RFC协议规定的。至于为什么是2个MSL而不是1个MSL，我还没有看到一个非常满意的解释。 四次挥手也并不总是四次挥手，中间的两个动作有时候是可以合并一起进行的，这个时候就成了三次挥手，主动关闭方就会从fin_wait_1状态直接进入到time_wait状态，跳过了fin_wait_2状态。 四、总结TCP状态转换是一个非常复杂的过程，本文仅对一些简单的基础知识点进行了类比讲解。关于TCP的更多知识还需要去搜寻相关技术文章进入深入学习。","categories":[{"name":"理解","slug":"理解","permalink":"http://kayleman.github.io/categories/理解/"}],"tags":[{"name":"TCP","slug":"TCP","permalink":"http://kayleman.github.io/tags/TCP/"}]},{"title":"Generative Adversarial Net（GAN）","slug":"生成对抗网络（GAN）","date":"2018-04-18T02:56:01.000Z","updated":"2018-04-18T08:06:25.000Z","comments":true,"path":"2018/04/18/生成对抗网络（GAN）/","link":"","permalink":"http://kayleman.github.io/2018/04/18/生成对抗网络（GAN）/","excerpt":"前言GAN（生成对抗网络）最早是由2014年NIPS的一篇文章：Generative Adversarial Net 所提出来的，是近几年来深度学习领域比较热门的一块。简单来说，GAN的主要思想就是一种二人零和博弈的思想（two-player game）。本文旨在浅显地理解传统的GAN，分享一下学习心得。","text":"前言GAN（生成对抗网络）最早是由2014年NIPS的一篇文章：Generative Adversarial Net 所提出来的，是近几年来深度学习领域比较热门的一块。简单来说，GAN的主要思想就是一种二人零和博弈的思想（two-player game）。本文旨在浅显地理解传统的GAN，分享一下学习心得。 什么是GAN？前面有提到了GAN其实就是一个博弈论中的二人零和博弈的思想，在GAN模型中博弈的双方分别是生成模型（generative model）和判别模型（discriminative）。生成模型和判别模型都类似于一个黑匣子，接受一个输入然后有一个输出。不同点在于生成模型G是从潜在空间（latent space）中随机采样作为输入，然后输出一个尽量与训练集中的真实样本接近的结果。判别模型D的输入则为真实样本或生成模型的输出，它的目的是将生成模型的输出从真实样本中尽可能地分别出来。判别模型是一个二分类器，判别一个样本来自于训练数据而不是生成模型生成的数据的概率。 打个比方说：生成模型G就好像一个假币制造团伙，专门制造假币来欺骗警察。判别模型D就好比是警察，拥有火眼金睛专门检测收到的是真币还是假币。生成模型也就是假币制造团伙的目的是生成（制造）出可以以假乱真的假币，使得判别模型(警察)无法辨别真伪。而判别模型（警察）的目标是想方设法地去检测出来生成模型（假币制造团伙）生成（制造）的假币。 简单地理解了GAN的构成之后，来看看结合实际用例。如下图所示，生成一个新的脸的模型： 我们首先要想清楚在使用GAN的时候的两个问题： 我们有什么？比如上面的这个图，我们有的只是真实采集而来的人脸样本数据集，仅此而已，而且很关键的一点是我们连人脸数据集的类标签都没有，也就是我们不知道那个人脸对应的是谁。 我们要得到什么至于要得到什么，不同的任务得到的东西不一样，我们只说最原始的GAN目的，那就是我们想通过输入一个噪声，模拟得到一个人脸图像，这个图像可以非常逼真以至于以假乱真。 再来理解下GAN的两个模型要做什么。首先判别模型，就是图中右半部分的网络，直观来看就是一个简单的神经网络结构，输入就是一副图像，输出就是一个概率值，用于判断真假使用（概率值大于0.5那就是真，小于0.5那就是假），真假也不过是人们定义的概率而已。其次是生成模型，生成模型要做什么呢，同样也可以看成是一个神经网络模型，输入是一组随机数Z，输出是一个图像，不再是一个数值而已。从图中可以看到，会存在两个数据集，一个是真实数据集，这好说。另一个是假的数据集，这个数据集就是由生成网络造（生成）出来的数据集。根据这个图我们再来理解一下GAN的目标是要干什么： 生成网络的目的：生成网络是造样本的，它的目的就是使得自己生成样本的能力尽可能强，强到什么程度呢，你判别网络没法判断我是真样本还是假样本。 判别网络的目的：就是能判别出来输入的一张图它是来自真实样本集还是假样本集。假如输入的是真样本，网络输出就接近1，输入的是假样本，网络输出接近0，那么很完美，达到了很好判别的目的。 有了这个理解我们再来看看为什么叫做对抗网络了。判别网络说，我很强，来一个样本我就知道它是来自真样本集还是假样本集。生成网络就不服了，说我也很强，我生成一个假样本，虽然我生成网络知道是假的，但是你判别网络不知道呀，我包装的非常逼真，以至于判别网络无法判断真假。那么用输出数值来解释就是，生成网络生成的假样本进去了判别网络以后，判别网络给出的结果是一个接近0.5的值，极限情况就是0.5，也就是说判别不出来了，这就是纳什平衡了。 由这个分析可以发现，生成网络与判别网络的目的正好是相反的，一个说我能判别的好，一个说我让你判别不好。所以叫做对抗，叫做博弈。那么最后的结果到底是谁赢呢？这就要归结到设计者，也就是我们希望谁赢了。作为设计者的我们，我们的目的是要得到以假乱真的样本，那么很自然的我们希望生成样本赢了，也就是希望生成样本很真，判别网络能力不足以区分真假样本。 如何训练GAN？知道了GAN大概的目的与设计思路，那么一个很自然的问题来了就是我们该如何用数学方法解决这么一个对抗问题。这就涉及到如何训练这样一个生成对抗网络模型了，还是先上一个图，用图来解释最直接： 需要注意的是生成模型与对抗模型可以说是完全独立的两个模型，好比就是完全独立的两个神经网络模型，他们之间没有什么联系。 那么训练这样的两个模型的大方法就是：单独交替迭代训练。 什么意思？因为是2个网络，不好一起训练，所以才去交替迭代训练，我们一一来看。 假设现在生成网络模型已经有了（当然可能不是最好的生成网络），那么给一堆随机数组，就会得到一堆假的样本集（因为不是最终的生成模型，那么现在生成网络可能就处于劣势，导致生成的样本就不咋地，可能很容易就被判别网络判别出来了说这货是假冒的），但是先不管这个，假设我们现在有了这样的假样本集，真样本集一直都有，现在我们人为的定义真假样本集的标签，因为我们希望真样本集的输出尽可能为1，假样本集为0，很明显这里我们就已经默认真样本集所有的类标签都为1，而假样本集的所有类标签都为0. 有人会说，在真样本集里面的人脸中，可能张三人脸和李四人脸不一样呀，对于这个问题我们需要理解的是，我们现在的任务是什么，我们是想分样本真假，而不是分真样本中那个是张三label、那个是李四label。况且我们也知道，原始真样本的label我们是不知道的。回过头来，我们现在有了真样本集以及它们的label（都是1）、假样本集以及它们的label（都是0），这样单就判别网络来说，此时问题就变成了一个再简单不过的有监督的二分类问题了，直接送到神经网络模型中训练就完事了。假设训练完了，下面我们来看生成网络。 对于生成网络，想想我们的目的，是生成尽可能逼真的样本。那么原始的生成网络生成的样本你怎么知道它真不真呢？就是送到判别网络中，所以在训练生成网络的时候，我们需要联合判别网络一起才能达到训练的目的。什么意思？就是如果我们单单只用生成网络，那么想想我们怎么去训练？误差来源在哪里？细想一下没有，但是如果我们把刚才的判别网络串接在生成网络的后面，这样我们就知道真假了，也就有了误差了。所以对于生成网络的训练其实是对生成-判别网络串接的训练，就像图中显示的那样。那么现在来分析一下样本，原始的噪声数组Z我们有，也就是生成了假样本我们有，此时很关键的一点来了，我们要把这些假样本的标签都设置为1，也就是认为这些假样本在生成网络训练的时候是真样本。那么为什么要这样呢？我们想想，是不是这样才能起到迷惑判别器的目的，也才能使得生成的假样本逐渐逼近为正样本。重新顺一下思路，现在对于生成网络的训练，我们有了样本集（只有假样本集，没有真样本集），有了对应的label（全为1），是不是就可以训练了？有人会问，这样只有一类样本，训练啥呀？谁说一类样本就不能训练了？只要有误差就行。还有人说，你这样一训练，判别网络的网络参数不是也跟着变吗？没错，这很关键，所以在训练这个串接的网络的时候，一个很重要的操作就是不要判别网络的参数发生变化，也就是不让它参数发生更新，只是把误差一直传，传到生成网络那块后更新生成网络的参数。这样就完成了生成网络的训练了。 在完成生成网络训练后，那么我们是不是可以根据目前新的生成网络再对先前的那些噪声Z生成新的假样本了，没错，并且训练后的假样本应该是更真了才对。然后又有了新的真假样本集（其实是新的假样本集），这样又可以重复上述过程了。我们把这个过程称作为单独交替训练。我们可以实现定义一个迭代次数，交替迭代到一定次数后停止即可。这个时候我们再去看一看噪声Z生成的假样本会发现，原来它已经很真了。 看完了这个过程是不是感觉GAN的设计真的很巧妙，个人觉得最值得称赞的地方可能在于这种假样本在训练过程中的真假变换，这也是博弈得以进行的关键之处。 数学公式描述文字的描述相信已经让大多数的人知道了这个过程，下面我们来看看原文中几个重要的数学公式描述，首先我们直接上原始论文中的目标公式吧： 上述这个公式说白了就是一个最大最小优化问题，其实对应的也就是上述的两个优化过程。有人说如果不看别的，能达看到这个公式就拍案叫绝的地步，那就是机器学习的顶级专家，同时也说明这个简单的公式意义重大。 这个公式既然是最大最小的优化，那就不是一步完成的，其实对比我们的分析过程也是这样的，这里先优化D，然后再去优化G，本质上是两个优化问题，把它拆解就如同下面两个公式： 优化D： 优化G： 可以看到，优化D的时候，也就是判别网络，其实没有生成网络什么事，后面的G(z)这里就相当于已经得到的假样本。优化D的公式的第一项，使的真样本x输入的时候，得到的结果越大越好，可以理解，因为需要真样本的预测结果越接近于1越好嘛。对于假样本，需要优化是的其结果越小越好，也就是D(G(z))越小越好，因为它的标签为0。但是呢第一项是越大，第二项是越小，这不矛盾了，所以呢把第二项改成1-D(G(z))，这样就是越大越好，两者合起来就是越大越好。 那么同样在优化G的时候，这个时候没有真样本什么事，所以把第一项直接却掉了。这个时候只有假样本，但是我们说这个时候是希望假样本的标签是1的，所以是D(G(z))越大越好，但是呢为了统一成1-D(G(z))的形式，那么只能是最小化1-D(G(z))，本质上没有区别，只是为了形式的统一。之后这两个优化模型可以合并起来写，就变成了最开始的那个最大最小目标函数了。 所以回过头来我们来看这个最大最小目标函数，里面包含了判别模型的优化，包含了生成模型的以假乱真的优化，完美的阐释了这样一个优美的理论。 GAN的强大之处有人说GAN强大之处在于可以自动的学习原始真实样本集的数据分布，不管这个分布多么的复杂，只要训练的足够好就可以学出来。针对这一点，感觉有必要好好理解一下为什么别人会这么说。 我们知道，传统的机器学习方法，我们一般都会定义一个什么模型让数据去学习。比如说假设我们知道原始数据属于高斯分布呀，只是不知道高斯分布的参数，这个时候我们定义高斯分布，然后利用数据去学习高斯分布的参数得到我们最终的模型。再比如说我们定义一个分类器，比如SVM，然后强行让数据进行东变西变，进行各种高维映射，最后可以变成一个简单的分布，SVM可以很轻易的进行二分类分开，其实SVM已经放松了这种映射关系了，但是也是给了一个模型，这个模型就是核映射（什么径向基函数等等），说白了其实也好像是你事先知道让数据该怎么映射一样，只是核映射的参数可以学习罢了。所有的这些方法都在直接或者间接的告诉数据你该怎么映射一样，只是不同的映射方法能力不一样。那么我们再来看看GAN，生成模型最后可以通过噪声生成一个完整的真实数据（比如人脸），说明生成模型已经掌握了从随机噪声到人脸数据的分布规律了，有了这个规律，想生成人脸还不容易。然而这个规律我们开始知道吗？显然不知道，如果让你说从随机噪声到人脸应该服从什么分布，你不可能知道。这是一层层映射之后组合起来的非常复杂的分布映射规律。然而GAN的机制可以学习到，也就是说GAN学习到了真实样本集的数据分布。 再拿原论文中的一张图来解释： 这张图表明的是GAN的生成网络如何一步步从均匀分布学习到正太分布的。原始数据x服从正太分布，这个过程你也没告诉生成网络说你得用正太分布来学习，但是生成网络学习到了。假设你改一下x的分布，不管什么分布，生成网络可能也能学到。这就是GAN可以自动学习真实数据的分布的强大之处。 还有人说GAN强大之处在于可以自动的定义潜在损失函数。 什么意思呢，这应该说的是判别网络可以自动学习到一个好的判别方法，其实就是等效的理解为可以学习到好的损失函数，来比较好或者不好的判别出来结果。虽然大的loss函数还是我们人为定义的，基本上对于多数GAN也都这么定义就可以了，但是判别网络潜在学习到的损失函数隐藏在网络之中，不同的问题这个函数就不一样，所以说可以自动学习这个潜在的损失函数。 最后现在的GAN已经到了五花八门的时候了，各种GAN应用也很多，理解底层原理再慢慢往上层扩展。GAN还是一个很厉害的东西，它使得现有问题从有监督学习慢慢过渡到无监督学习，而无监督学习才是自然界中普遍存在的，因为很多时候没有办法拿到监督信息的。要不Yann Lecun 赞叹GAN是机器学习近十年来最有意思的想法。","categories":[{"name":"论文笔记","slug":"论文笔记","permalink":"http://kayleman.github.io/categories/论文笔记/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"http://kayleman.github.io/tags/深度学习/"}]},{"title":"Python2到Python3代码的转换工具2to3.py","slug":"Python2到Python3代码的转换工具2to3.py","date":"2017-10-27T08:40:12.000Z","updated":"2017-10-27T08:43:07.000Z","comments":true,"path":"2017/10/27/Python2到Python3代码的转换工具2to3.py/","link":"","permalink":"http://kayleman.github.io/2017/10/27/Python2到Python3代码的转换工具2to3.py/","excerpt":"前言经常会遇到需要将Python2代码转换成Python3的情况.如果只是简单的改改print,那么直接手动改就行了,但是如果有很多地方需要修改就比较令人头疼.最近才知道Python官方就已经准备了一个转换工具:2to3.py 注:在Windows环境下","text":"前言经常会遇到需要将Python2代码转换成Python3的情况.如果只是简单的改改print,那么直接手动改就行了,但是如果有很多地方需要修改就比较令人头疼.最近才知道Python官方就已经准备了一个转换工具:2to3.py 注:在Windows环境下 所在位置无论你的Python是官网下载安装的还是Anaconda中带的.都可以在{Python_HOME}\\Tools\\scripts里面找到2to3.py 操作过程比如说我有一个Python2的.py文件需要修改,路径为:G:\\Code\\OSVOS-TensorFlow\\osvos.py 首先在终端进入到2to3.py这个文件所在的文件夹.也就是{Python_HOME}\\Tools\\scripts,我这里的Python是Anaconda3里的,所以我的路径是G:\\Anaconda3\\Tools\\scripts 输入python 2to3.py -w G:\\Code\\OSVOS-TensorFlow\\osvos.py-w这个参数是为了直接生成一个新的osvos.py文件代替我原来的osvos.py文件,同时会把原来的osvos.py文件加一个.bak后缀备份.于是目录下会多了一个osvos.py.bak文件,如果不想生成.bak文件,在运行的时候加上-n即可.如果不想看那一堆输出内容,加上-no-diffs即可. 如果要了解更多参数的使用方法,可以直接输入:python 2to3.py -h","categories":[{"name":"备忘","slug":"备忘","permalink":"http://kayleman.github.io/categories/备忘/"}],"tags":[{"name":"python","slug":"python","permalink":"http://kayleman.github.io/tags/python/"}]},{"title":"Java和python的代码命名大小写规范","slug":"代码命名大小写规范","date":"2017-09-07T02:31:40.000Z","updated":"2017-09-07T02:55:20.000Z","comments":true,"path":"2017/09/07/代码命名大小写规范/","link":"","permalink":"http://kayleman.github.io/2017/09/07/代码命名大小写规范/","excerpt":"前言代码命名这种利人利己的事情,还是要好好改正学习一下的.找了一篇比较简洁明了的博客,并修改了一些错误,记录一下备忘.最后再附上一个函数命名查询的网站.可直接输入中文查询.妈妈再也不用担心我想不出函数名啦.","text":"前言代码命名这种利人利己的事情,还是要好好改正学习一下的.找了一篇比较简洁明了的博客,并修改了一些错误,记录一下备忘.最后再附上一个函数命名查询的网站.可直接输入中文查询.妈妈再也不用担心我想不出函数名啦. Java命名规范 项目名称：全部小写 常量：都用大写。如：public static final String DBDRIVER = “…..”; 类名：大写开头： 如：public class Person{} 属性名：小写：如：String personName = “Kayle”; 方法名：小写：如：public String getPersonName() {return this.personName} 构造函数名：与类名称一样，所以也是大写开头。 包名：所有的单词都是小写：如：import java.io.* Python命名规范 模块名：小写字母，单词之间用_分割 如：rivet_detection 包名：小写字母，单词之间用_分割 如：rivet_detection 类名：单词首字母大写 如：python class LogRecord(object): 普通变量：小写字母，单词之间用_分割 如：exc_info 实例变量：以_开头，小写字母，单词之间用_分割 如:_exc_info，以一个下划线开头的标识符(_xxx)，不能访问的类属性，但可通过类提供的接口进行访问，不会被语句 “from module import *” 语句加载 私有实例变量：以__开头（2个下划线），小写字母，单词之间用_分割 如:__private_var ，外部访问会报错 专有变量：__开头（2个下划线），__结尾（2个下划线），一般为python的自有变量，不要以这种方式命名 如:__doc__ ，是系统定义的，具有特殊意义的标识符 普通函数：小写字母，单词之间用_分割： 如:get_name() 私有函数：以__开头（2个下划线），小写字母，单词之间用分割 如:__get_name() ，外部访问会报错. 函数命名查询网站http://unbug.github.io/codelf/ 参考http://blog.csdn.net/quiet_girl/article/details/73896791","categories":[{"name":"备忘","slug":"备忘","permalink":"http://kayleman.github.io/categories/备忘/"}],"tags":[{"name":"python","slug":"python","permalink":"http://kayleman.github.io/tags/python/"},{"name":"Java","slug":"Java","permalink":"http://kayleman.github.io/tags/Java/"}]},{"title":"修改Windows命令界面字体","slug":"修改Windows命令界面字体","date":"2017-08-08T10:26:59.000Z","updated":"2017-08-08T10:30:01.000Z","comments":true,"path":"2017/08/08/修改Windows命令界面字体/","link":"","permalink":"http://kayleman.github.io/2017/08/08/修改Windows命令界面字体/","excerpt":"前言平时在使用Windows的时候经常会用到命令界面，但是Windows命令界面所用的默认字体真的是看着很不舒服，于是就去找了一下修改Windows命令界面字体的方法。","text":"前言平时在使用Windows的时候经常会用到命令界面，但是Windows命令界面所用的默认字体真的是看着很不舒服，于是就去找了一下修改Windows命令界面字体的方法。 默认情况在默认的情况下，命令界面的显示效果如下图所示： 这个字体让我看着很不舒服，在窗口的顶端边栏右键，在弹出的菜单中选择属性，可以看到以下所示的属性： 当前的代码页是936： 字体选项界面显示的是： 可以看到默认的只有两种字体可以选择，并且同样都是看着不舒服的字体。 修改默认字体我们可以打开注册表看看，打开注册表定位到HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Console\\TrueTypeFont就可以看到Windows下的其它字体。 其中的000和0000是我后来自己添加进去的，其它都是默认存在的字体。我们可以看到有Consolas字体，这个字体看着还是挺舒服的。0和00两项都是代码页437页可用的字体，可以在命令界面输入chcp [codepage]来进行切换，例如下图就是输入chcp 437后得到的结果。如图： 现在可以再来看一下属性页面，当前代码页和可选字体都已经发生了改变。 现在的当前代码页是437： 可选择字体多出了Consolas和Lucida Console，还有一个Bitstream Vera Sans Mono字体是我在注册表添加了一个值所多出来的。 我们可以看一下选择了Consolas之后的效果： 看着感觉还不错，如果你还想要用别的字体的话，就需要在注册表中添加命令行程序可用的字体了。首先按上面的步骤打开注册表，增加一项名字为000的字符串值，并将其值设置为你想要用的字体的名字（当然这个字体是要你的系统字体中有的，我专门下载了Mac OS上的专有字体Monaco想进行更换，但是并没有出现这个字体选项，可能不属于系统自带的字体吧。），可以看到我增加了一个名为Bitstream Vera Sans Mono的字体，可以看到效果图如下： 参考http://www.cnblogs.com/kangflict/p/4111010.html","categories":[{"name":"备忘","slug":"备忘","permalink":"http://kayleman.github.io/categories/备忘/"}],"tags":[{"name":"Windows7","slug":"Windows7","permalink":"http://kayleman.github.io/tags/Windows7/"}]},{"title":"如何将iPhone/iPad备份到外置硬盘中","slug":"如何将iPhone备份到外置硬盘中","date":"2017-07-20T10:05:18.000Z","updated":"2017-08-08T07:50:37.000Z","comments":true,"path":"2017/07/20/如何将iPhone备份到外置硬盘中/","link":"","permalink":"http://kayleman.github.io/2017/07/20/如何将iPhone备份到外置硬盘中/","excerpt":"前言因为偶然发现在Web上登录iCloud使用”查找我的iPhone”功能不需要进行二次验证, 可以直接登录, 并且能够锁定自己的设备, 甚至还能够直接抹除设备上的数据, 为了避免在密码泄露的时候被不怀好意的人抹除数据造成损失, 于是决定将iPhone的数据备份. 很多人可能都只是用iCloud进行数据的备份, 但是iCloud免费空间太小不说, 而且备份极其不稳定, 经常不能成功备份. 它所显示的备份成功, 其实有时候并没有真正地备份成功. 有次在恢复备份数据的时候才发现没有备份成功, 导致很多数据丢失. 所以, 我选择了稳定的iTunes进行备份. 但是有一个问题, iTunes默认情况下只能备份到内置磁盘, 而Mac的存储空间通常比较紧张, 所以就考虑把备份放到移动硬盘上. 我使用的是手动修改备份路径的方法.","text":"前言因为偶然发现在Web上登录iCloud使用”查找我的iPhone”功能不需要进行二次验证, 可以直接登录, 并且能够锁定自己的设备, 甚至还能够直接抹除设备上的数据, 为了避免在密码泄露的时候被不怀好意的人抹除数据造成损失, 于是决定将iPhone的数据备份. 很多人可能都只是用iCloud进行数据的备份, 但是iCloud免费空间太小不说, 而且备份极其不稳定, 经常不能成功备份. 它所显示的备份成功, 其实有时候并没有真正地备份成功. 有次在恢复备份数据的时候才发现没有备份成功, 导致很多数据丢失. 所以, 我选择了稳定的iTunes进行备份. 但是有一个问题, iTunes默认情况下只能备份到内置磁盘, 而Mac的存储空间通常比较紧张, 所以就考虑把备份放到移动硬盘上. 我使用的是手动修改备份路径的方法. 迁移旧的备份文件 退出iTunes, 连接你的外置硬盘. 打开Finder, 按下 Command + Shift + G快捷键前往文件夹, 在弹出的窗口中输入以下路径(iTunes的默认备份路径):~/Library/Application Support/MobileSync/ 将整个Backup拷贝到外置硬盘中(我的外置硬盘名字叫MacBackup, 并且在里面新建了个文件夹, 名字叫做iPhoneBackup, 所以我是拷贝到这个iPhoneBackup文件夹中, 你可以根据自己的情况对应地修改下文中命令中的路径名称). 拷贝完之后, 需要将这个Backup文件夹重命名为其他名字, 或者直接把这个文件夹给删除. 因为如果不这样做, 后面在进行软连接的时候, 会出现文件夹已存在的错误.如下图: 创建符号链接为了让iTunes能够备份到外置硬盘, 关键是在原备份文件夹和外置文件夹之间建立符号链接(Symbolic Link, 也称软链接, 类似于Windows的快捷方式和OSX中的替身文件). 从而使得我们能够欺骗iTunes, 让它误以为是备份在了内置硬盘上. 打开Finder, 选中外置硬盘中的iPhoneBackup文件夹. 打开终端, 将iPhoneBackup文件夹拖入终端, 得到一个路径:/Volumes/MacBackup/iPhoneBackup 复制这个路径, 和iTunes的默认备份路径一起, 组合成下面的命令(不要落掉斜杠和空格,建议直接复制):ln -s /Volumes/MacBackup/iPhoneBackup/Backup ~/Library/Application\\ Support/MobileSync/ 重启终端, 执行第3步中的命令. 完成后, 查看iTunes默认备份文件夹, 发现一个带着小箭头的Backup文件夹, 表明软链接建立完成. 备份打开iTunes, 选择备份到本电脑, 立即备份即可自动备份到外置硬盘. 参考https://sspai.com/post/33524","categories":[{"name":"备忘","slug":"备忘","permalink":"http://kayleman.github.io/categories/备忘/"}],"tags":[{"name":"教程","slug":"教程","permalink":"http://kayleman.github.io/tags/教程/"}]},{"title":"利用Github Pages + Hexo搭建自己的博客","slug":"利用Github Pages + Hexo搭建自己的博客","date":"2017-06-29T08:28:38.000Z","updated":"2018-04-18T03:02:41.000Z","comments":true,"path":"2017/06/29/利用Github Pages + Hexo搭建自己的博客/","link":"","permalink":"http://kayleman.github.io/2017/06/29/利用Github Pages + Hexo搭建自己的博客/","excerpt":"前言一直想要搭建一个自己的博客，用来记录自己的学习到的一些东西，方便以后忘记了来翻看。那么就用本文记录一下在搭建博客过程中遇到的一些坑。 首先要说明本文是在Mac环境下搭建的，Windows环境下面没有尝试，但是根据Wiyee同学说的都是大同小异罢了。 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。","text":"前言一直想要搭建一个自己的博客，用来记录自己的学习到的一些东西，方便以后忘记了来翻看。那么就用本文记录一下在搭建博客过程中遇到的一些坑。 首先要说明本文是在Mac环境下搭建的，Windows环境下面没有尝试，但是根据Wiyee同学说的都是大同小异罢了。 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 1.Github PagesGithub Pages 是面向用户、组织和项目开放的公共静态页面搭建托管服务，站点可以被免费托管在Github 上，你可以选择使用Github Pages 默认提供的域名github.io 或者自定义域名来发布站点。 创建Github Pages的前提是你有一个Github帐号就行了，然后利用这个帐号创建一个仓库，但是这个仓库是有规则的，其格式必须为：yourusername.github.io。其中yourusername是你的Github用户名，比如说我的用户名是kayleman，所以我的仓库格式是kayleman.github.io。 没有Github的朋友可以点击这里进行注册。 登陆Github后可以在右边栏点击New repository创建一个新的仓库。如下图： 在Repository name的位置输入你的仓库名，如下图： 这里是因为我拿自己的仓库名做示范，而仓库名是必须要唯一的，所以才会提示仓库名已存在，接下来点击Create repository就行了。 2.环境准备和搭建安装Hexo的过程很简单，但是在安装前必须要确定你的电脑是否有以下程序： Node.js Git 如果没有的话就需要依次进行安装。 Git具体的配置可以上网搜一下，这里不再赘述。 安装Node.js到Node.js官网去下载相应平台的最新版本安装即可 安装Git使用 Homebrew，在终端输入brew install git进行安装 安装Hexo在终端输入npm install -g hexo-cli 更详细的可以见Hexo的官方文档。 建站Hexo安装好了之后，就可以开始建站了，通过终端cd到将要建站的位置，输入以下命令： 123hexo init yournamecd yournamenpm install 其中yourname可以任意取，比如我的叫Hexo， 关于建站的更多信息你可以参考官方文档，点击这里。 官方文档没有讲解如何配置与Github Pages进行关联，在此简单说明一下。进入到你的站点，也就是yourname文件夹，下文统一使用我自己的文件夹名Hexo方便描述。进入到文件夹以后你可以看到_config.yml这个文件，这是一个配置文件，是用来配置信息的。用编辑器打开_config.yml拉到最下面，你可以看到有deply和type字段，可以参考我的例子如下输入： 1234deploy: type: git repo: https://github.com/Kayleman/Kayleman.github.io.git branch: master 其中repo：后面的就改成你的Github Pages提交代码的git地址。 你的git地址在你刚才创建好的Github Pages仓库就能找到。 到此为止，你可以进入你的站点文件夹，使用hexo s命令，如果你看到Hexo is running at http://localhost:4000/. Press Ctrl+C to stop这么一句话，那么请打开你的浏览器输入http://localhost:4000/你就可以看到最初始的hexo界面了，是不是有点丑？不要紧，后期我们还可以修改页面的主题来更换样式。 发布刚才那样只是能够在本地显示，还没有上传到Github Pages服务器上面，所以我们需要在站点里输入以下命令： 123hexo cleanhexo ghexo d 其中第一条命令是清楚缓存，第二条命令全名是hexo generate，是用来生成静态文件的，第三条命令全名是hexo deploy，这条命令是用来把本地的文件发布到Github Pages上的。一般平时就使用这几个命令，更多命令可以参考官方文档 在我刚开始使用hexo d部署的时候出现了not found的问题，如果遇到了这个问题，请先输入： 1npm install hexo-deployer-git --save 然后再运行hexo d进行尝试。 为了方便hexo g和hexo d可以组合起来写，如下： 1hexo d -g 写文章写文章可以使用命令界面输入命令来完成，但是我觉得有点繁琐也不利于排版，于是就没用使用这种方法。由于最终上传的是.md文件，是markdown文件，关于markdown的一些简单语法你可以上网查阅一下，还是挺简单的。(我本人在Windows系统下使用MarkdownPad 2来编辑md文件，在Mac系统下是用MacDown，都挺好用) 在我们写好文章之后，可以直接把.md文件放到Hexo/source/_post目录下，再发布到Github Pages上你就可以看到文章了，稍微有那么一会的延迟，如果你没有绑定域名的话，在浏览器输入你的仓库地址，比如我的是kayleman.github.io就可以看到你的博客页面了。 还有一点就是在编辑文章的时候，可以在适当位置添加以下代码： 1&lt;!-- more --&gt; more以上是文章的摘要，在主页显示，more以下需要点击read more链接才能打开全文显示，可以有效避免博客主页被过多地占用。例如我的博客效果如下： Hexo主题的更换前面已经看到了，初始化的页面是非常丑的，我们可以更换Hexo的主题，在知乎上有这个话题，可以点击这里去参考一下。找到喜欢的主题后安装主题就是一条命令，比如我使用的是icarus主题 1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 从git上clone下来放到Hexo/theme路径下。然后打开Hexo/_config.yml文件，修改里面theme的参数为icarus。 之后再根据主题作者Github上提供的方法一步步配置icarus文件夹里面的_config.yml文件。 至于具体的主题配置和一些模块的设置我会再详细地写一篇博客，这里不再赘述。 域名绑定要绑定域名，首先你要去注册一个域名，我是在万网注册的，你可以点击这里进行注册，或者去其它的域名注册商那注册。对于域名的具体购买等步骤这里也不再赘述。 这里需要提一下的就是注册的域名如何与Github Pages进行绑定。首先在本地站点也就是Hexo目录下的source下面添加一个CNAME文件，不带后缀，效果如下： 用文本编辑器打开，里面添加你的域名信息，不加http://，如下图： 在万网的域名控制中心，点击解析，然后添加解析，详细的方法可以见域名注册商的网站，万网的方法点击这里。 参考https://hexo.io/zh-cn/docs/index.html http://ibruce.info/2013/11/22/hexo-your-blog/ http://www.jianshu.com/p/834d7cc0668d","categories":[{"name":"备忘","slug":"备忘","permalink":"http://kayleman.github.io/categories/备忘/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://kayleman.github.io/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"http://kayleman.github.io/tags/博客/"}]},{"title":"Win7遇到的小问题备忘","slug":"win7自己遇到的小问题总结","date":"2017-06-23T05:25:21.000Z","updated":"2017-06-29T08:51:52.000Z","comments":true,"path":"2017/06/23/win7自己遇到的小问题总结/","link":"","permalink":"http://kayleman.github.io/2017/06/23/win7自己遇到的小问题总结/","excerpt":"前言本文记录了我自己在使用win7过程中遇到的一些小问题,整理起来备忘.","text":"前言本文记录了我自己在使用win7过程中遇到的一些小问题,整理起来备忘. 1.开机自动默认打开numlock键，想要关闭。 在开始菜单搜索栏输入 regedit ，打开注册表定位到下面键值HKEY_USERS\\.DEFAULT\\Control Panel\\Keyboard 修改InitialKeyboardIndicators的键值 设置为“2”，小键盘默认为开； 设置为“1”，小键盘默认为关闭； 设置为“0”，则系统关机前Unm Lock是什么状态，开机后还是什么状态。 2.win7系统开机，还没输密码直接显示用户密码错误。 在开始菜单搜索框输入 “netplwiz” 按回车，打开高级用户控制面板； 在高级用户控制面板中，“要使用本机，用户需输入用户名和密码(E)”项的勾选打勾. 3.开机界面什么都没有 Ctrl + Shift + Esc调出任务管理器,直接把explorer进程给关闭 在任务管理器左上角选择”文件” –&gt; “新建任务” 输入explorer以管理员身份运行。 4.怎么上Google 用GoGoTester找可用的Google IP 在cmd界面ping一下IP是否可用，确认可用 到C:\\Windows\\System32\\drivers\\etc修改hosts 最好刷新一下dns，即在cmd界面输入ipconfig/flushdns 或者直接去www.laod.cn这个网站上去找hosts文件,下载下来,同样按照第3步替换hosts文件 5.怎么不让Google跳转到hk或者其它地区第一次直接在浏览器打www.google.com的时候经常会出现无法连接的情况 可以直接输入https://www.google.com 然后有可能会被跳转到.hk的香港的服务器去,由于香港的服务器也是被屏蔽了很多信息的 如果不想跳转可以一次性直接输入https://www.google.com/ncr 后面的/ncr代表禁止国别跳转 之后就不需要在次输入/ncr会默认不跳转 6.怎么在chrome搜索框默认用Google搜索而不跳转到hk 在Google界面随便搜索一个词比如说“asd” 把地址栏里的asd对应替换成%s，全部复制 到设置里添加搜索引擎 把这个新添加的设为默认搜索引擎 7.win7怎么设置定时关机 最简单的就用一些360，QQ管家，QQ音乐，WIFI共享精灵之类的 win7里面有自带的关机程序，在Windows\\System32\\Shutdown.exe，可以直接打开这个可执行应用程序 也可以选择“开始-&gt;运行-&gt;cmd”打开命令窗口，比如你的电脑要在22:00关机，输入“at 22:00 Shutdown -s” 到了22点电脑就会出现“系统关机”对话框，默认有30秒钟的倒计时并提示你保存工作。 如果你想以倒计时的方式关机，可以输入“Shutdown.exe -s -t 3600”，表示60分钟后自动关机，“3600”代表60分钟 设置好自动关机后，如果想取消的话，可以在运行中输入“shutdown -a”。 另外输入 “shutdown -i”，则可以打开设置自动关机对话框，对自动关机进行设置。 Shutdown.exe的参数，每个都具有特定的用途，执行每一个都会产生不同的效果，比如 -s：就表示关闭本地计算机 -a：表示取消关机操作 -f：强行关闭应用程序 -m 计算机名：控制远程计算机 -i：显示图形用户界面，但必须是Shutdown的第一个选项 -l：注销当前用户 -r：关机并重启 -t 时间：设置关机倒计时 -c “消息内容”：输入关机对话框中的消息内容 8.不格式化硬盘转换硬盘格式（FAT32转NTFS） 运行输入cmd进入命令界面 输入convert c: /fs:ntfs（其中C就是指C盘，转哪个写哪个盘名） 9.音量控制图标不见了怎么办将explorer.exe重启,具体怎么重启见前面第3条 10.图片只显示缩略图怎么办 打开我的电脑 点开工具，选择文件夹选项 点击查看，把始终显示图标勾选去掉。","categories":[{"name":"备忘","slug":"备忘","permalink":"http://kayleman.github.io/categories/备忘/"}],"tags":[{"name":"Windows7","slug":"Windows7","permalink":"http://kayleman.github.io/tags/Windows7/"}]},{"title":"Ubuntu16.04虚拟机设置固定IP的方法","slug":"Ubuntu16.04虚拟机设置固定IP上网","date":"2017-06-23T05:25:20.000Z","updated":"2017-06-29T08:48:48.000Z","comments":true,"path":"2017/06/23/Ubuntu16.04虚拟机设置固定IP上网/","link":"","permalink":"http://kayleman.github.io/2017/06/23/Ubuntu16.04虚拟机设置固定IP上网/","excerpt":"前言由于经常需要直接在主机通过IP连接到虚拟机,所以上网搜了一些Ubuntu设置固定IP上网的方法,其中遇到了一些问题,参考了大神的博客内容,之后会列出原文链接,如果侵犯了您的权利,请与我联系删除,谢谢. 设置固定IP的方法很多，大家都知道虚拟机上网有三种模式：bridged、host-only和NAT， 其中NAT模式对应VMnet8虚拟网络，host-only模式对应VMnet1虚拟网络，bridged模式对应 VMnet0虚拟网络，都是由VMware虚拟机自动配置而生成的，不需要用户自行设置。VMnet8和VMnet1提供DHCP服务，VMnet0虚拟 网络则不提供。 当前环境:虚拟机版本:VMware WorkStation 12系统版本:Ubuntu 16.04","text":"前言由于经常需要直接在主机通过IP连接到虚拟机,所以上网搜了一些Ubuntu设置固定IP上网的方法,其中遇到了一些问题,参考了大神的博客内容,之后会列出原文链接,如果侵犯了您的权利,请与我联系删除,谢谢. 设置固定IP的方法很多，大家都知道虚拟机上网有三种模式：bridged、host-only和NAT， 其中NAT模式对应VMnet8虚拟网络，host-only模式对应VMnet1虚拟网络，bridged模式对应 VMnet0虚拟网络，都是由VMware虚拟机自动配置而生成的，不需要用户自行设置。VMnet8和VMnet1提供DHCP服务，VMnet0虚拟 网络则不提供。 当前环境:虚拟机版本:VMware WorkStation 12系统版本:Ubuntu 16.04 1. 设置虚拟机上网方式为NAT在虚拟机设置中的网络适配器里,选择NAT模式 2. 配置VMnet8虚拟网络 在VMware的编辑选项中打开虚拟网络编辑器 按照下图中对虚拟网络进行设置,虚拟网络的列表里默认是有VMnet0,VMnet1和VMnet8三种,我只有一种是因为我把另外两种给移除了,在这里我们选择VMnet8网络,其中子网IP根据自己的情况进行设置,只要不把原来已有的给占用即可. 3. 进入到Ubuntu系统中配置网络主要配置下面三个方面的内容： 修改文件/etc/network/interfaces，这里是IP、网关、掩码等的一些配置； 修改文件/etc/resolv.conf，这个文件保存DNS的有关信息； 解决resolv.conf被重写问题； 重启虚拟机网络 (1).修改文件/etc/network/interfaces输入命令:1sudo vi /etc/network/interfaces 或者: 1sudo gedit /etc/network/interfaces 配置如下: 1234567891011#interfaces(5) file used by ifup(8) and ifdown(8)auto loiface lo inet loopbackauto ens33iface ens33 inet staticaddress 192.168.8.100netmask 255.255.255.0gateway 192.168.8.2dns-nameservers 8.8.8.8 其中较新版本的比如我的Ubuntu16.04 就是ens33,有的版本是eth0, 具体可以在终端输入ifconfig命令查看,如图: 另外其中的网关要和虚拟网络编辑器中设置的一致,一般好像为192.168.XXX.2 上面最后一行设置的DNS不是必要的,可在下一步设置,这一步的优先级比resolv.conf中高,会优先在这一步读取DNS,如果没有配置才会去resolve.conf里面查找. (2)修改文件/etc/resolv.conf输入命令: 1sudo vi /etc/resolv.conf 或 1sudo gedit /etc/resolv.conf 配置如下: 1nameserver 8.8.8.8 这里具体DNS因人而异 (3)解决resolv.conf被重写问题第二步中你虽然配置了DNS，但是每次重启虚拟机或重启网络后/etc/resolv.conf文件就会被重写，也就是又恢复原样了，你以前的配置就不存在了，每次都要手动配置是极不可取的，所以这步是必须的，首先我们要搞清楚resolv.conf被重写的原因和机制，这在不同 Ubuntu版本下有所差异。 在这一步,教程原文上有两种办法,第一种是根据不同系统版本来采取不同的办法,第二种是于版本无关,通用的做法.我选了第二种,如果想看第一种方法,可以在文末的原文链接里去看. 第二种办法就是在前面第(1)步中在最后面直接加上你的DNS地址,因为interfaces优先级比resolv.conf高,会优先看interfaces里面的DNS. (4)重启虚拟机网络配置完成后需要重启一下网络: 1sudo service networking restart 或者 1sudo /etc/init.d/networking restart 在这一步我重启网络失败了,只能选择了下面的重启网卡 12sudo ifconfig eth0 down sudo ifconfig eth0 up 赶紧试试是不是可以了 参考:原文链接","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://kayleman.github.io/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://kayleman.github.io/tags/Ubuntu/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://kayleman.github.io/tags/虚拟机/"}]},{"title":"Ubuntu虚拟机如何与主机共享科学上网","slug":"虚拟机里面的Ubuntu怎么和主机共享科学上网","date":"2017-06-23T05:25:17.000Z","updated":"2017-06-29T08:50:19.000Z","comments":true,"path":"2017/06/23/虚拟机里面的Ubuntu怎么和主机共享科学上网/","link":"","permalink":"http://kayleman.github.io/2017/06/23/虚拟机里面的Ubuntu怎么和主机共享科学上网/","excerpt":"前言主机已经科学上网了,希望虚拟机里面的Ubuntu也能够科学上网,要怎么做呢? 我用的科学上网软件是ShadowSocks,关于这个软件怎么科学上网网上有非常多的教程,这里就不够多介绍了","text":"前言主机已经科学上网了,希望虚拟机里面的Ubuntu也能够科学上网,要怎么做呢? 我用的科学上网软件是ShadowSocks,关于这个软件怎么科学上网网上有非常多的教程,这里就不够多介绍了 1.通过ShadowSocks科学上网通常这类软件里面都有允许来自局域网的连接之类的选项 勾选这个选项,然后查看一下代理端口是多少,一般默认是1080 2.查看主机的ip地址我主机是Windows系统,在命令窗口输入ipconfig,得到自己的主机ip 3.在Ubuntu下面填写代理在Ubuntu中打开Network,选择下面的Network proxy,选择Manual手动模式,将主机的IP和代理端口填入 完成!","categories":[{"name":"科学上网","slug":"科学上网","permalink":"http://kayleman.github.io/categories/科学上网/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://kayleman.github.io/tags/Ubuntu/"},{"name":"科学上网","slug":"科学上网","permalink":"http://kayleman.github.io/tags/科学上网/"}]},{"title":"Mac下Vim安装NERDTree插件的方法","slug":"Mac下Vim安装NERDTree插件","date":"2017-06-23T05:25:15.000Z","updated":"2017-06-29T08:49:30.000Z","comments":true,"path":"2017/06/23/Mac下Vim安装NERDTree插件/","link":"","permalink":"http://kayleman.github.io/2017/06/23/Mac下Vim安装NERDTree插件/","excerpt":"前言相信所有使用 vim 的同学都知道文件管理插件 NERDTree，这个几乎是所有拥护 vim 的开发人员都会使用的插件, 本文简单介绍了 NERDTree 的安装.","text":"前言相信所有使用 vim 的同学都知道文件管理插件 NERDTree，这个几乎是所有拥护 vim 的开发人员都会使用的插件, 本文简单介绍了 NERDTree 的安装. 1.安装pathogen.vim在Terminal输入以下命令,创建.vim文件夹和下面的autoload和bundle子文件夹,同时将pathogen.vim下载到autoload里面 12mkdir -p ~/.vim/autoload ~/.vim/bundle &amp;&amp; \\curl -LSso ~/.vim/autoload/pathogen.vim https://tpo.pe/pathogen.vim 通过vim ~/.vimrc编辑vim配置文件,将 1execute pathogen#infect() 添加到vimrc中 2.安装NERDTree进入到bundle文件夹,并且把NERDTree下载在这个目录下12cd ~/.vim/bundlegit clone https://github.com/scrooloose/nerdtree.git 在Terminal下输入vim进入vim窗口,输入:NERDTree启动NERDTree,在确定NERDTree已经安装成功后,为了避免以后每次开启都需要输入:NERDTree较为麻烦,为它设置一个快捷键 定义快捷键,键入vim ~/.vimrc按i进入插入模式输入nnoremap &lt;silent&gt; &lt;F5&gt; :NERDTree&lt;CR&gt;按Esc键返回Normal状态并输入:wq保存退出。定义F5为显示树状目录的快捷键。 参考http://jingyan.baidu.com/article/59a015e3a33404f7948865d2.htmlhttp://blog.chinaunix.net/uid-20032401-id-5706833.htmlhttps://github.com/johnbellone/vim","categories":[{"name":"Vim","slug":"Vim","permalink":"http://kayleman.github.io/categories/Vim/"}],"tags":[{"name":"Vim","slug":"Vim","permalink":"http://kayleman.github.io/tags/Vim/"},{"name":"插件","slug":"插件","permalink":"http://kayleman.github.io/tags/插件/"}]}]}