{"meta":{"title":"Kayle's Blog","subtitle":"Never forget to say \"thanks\".","description":"Record my learning process and share it.","author":"Kayle Zhuang","url":"http://kayleman.github.io"},"pages":[{"title":"","date":"2017-06-24T08:24:40.000Z","updated":"2017-06-24T08:24:40.000Z","comments":true,"path":"404.html","permalink":"http://kayleman.github.io/404.html","excerpt":"","text":""},{"title":"About","date":"2017-06-24T04:59:38.000Z","updated":"2017-06-24T04:59:38.000Z","comments":true,"path":"about/index.html","permalink":"http://kayleman.github.io/about/index.html","excerpt":"","text":"昔日寒山问拾得曰：世间有人谤我、欺我、辱我、笑我、轻我、贱我、恶我、骗我、如何处治乎？ 拾得曰：只要忍他、让他、由他、避他、耐他、敬他、不要理他，再待几年你且看他。"},{"title":"tags","date":"2017-06-23T12:41:18.000Z","updated":"2017-06-23T12:41:18.000Z","comments":true,"path":"tags/index.html","permalink":"http://kayleman.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-06-23T12:41:01.000Z","updated":"2017-06-23T12:41:01.000Z","comments":true,"path":"categories/index.html","permalink":"http://kayleman.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"理解TCP三次握手与四次挥手","slug":"理解TCP三次握手与四次挥手","date":"2018-06-28T13:34:34.000Z","updated":"2018-06-28T16:00:56.000Z","comments":true,"path":"2018/06/28/理解TCP三次握手与四次挥手/","link":"","permalink":"http://kayleman.github.io/2018/06/28/理解TCP三次握手与四次挥手/","excerpt":"前言TCP三次握手和四次挥手的问题在是最基础的问题之一。本文尝试使用动画来对这个知识点进行讲解，期望可以更加简单地地理解TCP交互的本质。","text":"前言TCP三次握手和四次挥手的问题在是最基础的问题之一。本文尝试使用动画来对这个知识点进行讲解，期望可以更加简单地地理解TCP交互的本质。 一、TCP 三次握手TCP三次握手就好比两个人在街上隔着50米看见了对方，但是因为雾霾等原因不能100%确认，所以要通过招手的方式相互确定对方是否认识自己。 张三首先向李四招手(syn)，李四看到张三向自己招手后，向对方点了点头挤出了一个微笑(ack)。张三看到李四微笑后确认了李四成功辨认出了自己(进入estalished状态)。 但是李四还有点狐疑，向四周看了一看，有没有可能张三是在看别人呢，他也需要确认一下。所以李四也向张三招了招手(syn)，张三看到李四向自己招手后知道对方是在寻求自己的确认，于是也点了点头挤出了微笑(ack)，李四看到对方的微笑后确认了张三就是在向自己打招呼(进入established状态)。 于是两人加快步伐，走到了一起，相互拥抱。 我们看到这个过程中一共是四个动作，张三招手–&gt;李四点头微笑–&gt;李四招手–&gt;张三点头微笑。其中李四连续进行了2个动作，先是点头微笑(回复对方)，然后再次招手(寻求确认)，实际上可以将这两个动作合一，招手的同时点头和微笑(syn+ack)。于是四个动作就简化成了三个动作，张三招手–&gt;李四点头微笑并招手–&gt;张三点头微笑。这就是三次握手的本质，中间的一次动作是两个动作的合并。 我们看到有两个中间状态，syn_sent和syn_rcvd，这两个状态叫着「半打开」状态，就是向对方招手了，但是还没来得及看到对方的点头微笑。syn_sent是主动打开方的「半打开」状态，syn_rcvd是被动打开方的「半打开」状态。客户端是主动打开方，服务器是被动打开方。 syn_sent: syn package has been sent syn_rcvd: syn package has been received 二、TCP 数据传输TCP 数据传输就是两个人隔空对话，差了一点距离，所以需要对方反复确认听见了自己的话。 张三喊了一句话(data)，李四听见了之后要向张三回复自己听见了(ack)。 如果张三喊了一句，半天没听到李四回复，张三就认为自己的话被大风吹走了，李四没听见，所以需要重新喊话，这就是「tcp重传」。 也有可能是李四听到了张三的话，但是李四向张三的回复被大风吹走了，以至于张三没听见李四的回复。张三并不能判断究竟是自己的话被大风吹走了还是李四的回复被大风吹走了，张三也不用管，重传一下就是。 既然会重传，李四就有可能同一句话听见了两次，这就是「去重」。「重传」和「去重」工作操作系统的网络内核模块都已经帮我们处理好了，用户层是不用关心的。 张三可以向李四喊话，同样李四也可以向张三喊话，因为tcp链接是「双工的」，双方都可以主动发起数据传输。不过无论是哪方喊话，都需要收到对方的确认才能认为对方收到了自己的喊话。 张三可能是个高射炮，一说连说了八句话，这时候李四可以不用一句一句回复，而是连续听了这八句话之后，一起向对方回复说前面你说的八句话我都听见了，这就是批量ack。但是张三也不能一次性说了太多话，李四的脑子短时间可能无法消化太多，两人之间需要有协商好的合适的发送和接受速率，这个就是「TCP窗口大小」。 网络环境的数据交互同人类之间的对话还要复杂一些，它存在数据包乱序的现象。同一个来源发出来的不同数据包在「网际路由」上可能会走过不同的路径，最终达到同一个地方时，顺序就不一样了。操作系统的网络内核模块会负责对数据包进行排序，到用户层时顺序就已经完全一致了。 三、TCP 四次挥手TCP断开链接的过程和建立链接的过程比较类似，只不过中间的两部并不总是会合成一步走，所以它分成了4个动作，张三挥手(fin)–&gt;李四伤感地微笑(ack)–&gt;李四挥手(fin)–&gt;张三伤感地微笑(ack)。 之所以中间的两个动作没有合并，是因为tcp存在「半关闭」状态，也就是单向关闭。张三已经挥了手，可是人还没有走，只是不再说话，但是耳朵还是可以继续听，李四呢继续喊话。等待李四累了，也不再说话了，超张三挥了挥手，张三伤感地微笑了一下，才彻底结束了。 上面有一个非常特殊的状态time_wait，它是主动关闭的一方在回复完对方的挥手后进入的一个长期状态，这个状态标准的持续时间是4分钟，4分钟后才会进入到closed状态，释放套接字资源。不过在具体实现上这个时间是可以调整的。 它就好比主动分手方要承担的责任，是你提出的要分手，你得付出代价。这个后果就是持续4分钟的time_wait状态，不能释放套接字资源(端口)，就好比守寡期，这段时间内套接字资源(端口)不得回收利用。 它的作用是重传最后一个ack报文，确保对方可以收到。因为如果对方没有收到ack的话，会重传fin报文，处于time_wait状态的套接字会立即向对方重发ack报文。 同时在这段时间内，该链接在对话期间于网际路由上产生的残留报文(因为路径过于崎岖，数据报文走的时间太长，重传的报文都收到了，原始报文还在路上)传过来时，都会被立即丢弃掉。4分钟的时间足以使得这些残留报文彻底消逝。不然当新的端口被重复利用时，这些残留报文可能会干扰新的链接。 4分钟就是2个MSL，每个MSL是2分钟。MSL就是maximium segment lifetime——最长报文寿命。这个时间是由官方RFC协议规定的。至于为什么是2个MSL而不是1个MSL，我还没有看到一个非常满意的解释。 四次挥手也并不总是四次挥手，中间的两个动作有时候是可以合并一起进行的，这个时候就成了三次挥手，主动关闭方就会从fin_wait_1状态直接进入到time_wait状态，跳过了fin_wait_2状态。 四、总结TCP状态转换是一个非常复杂的过程，本文仅对一些简单的基础知识点进行了类比讲解。关于TCP的更多知识还需要去搜寻相关技术文章进入深入学习。","categories":[{"name":"理解","slug":"理解","permalink":"http://kayleman.github.io/categories/理解/"}],"tags":[{"name":"TCP","slug":"TCP","permalink":"http://kayleman.github.io/tags/TCP/"}]},{"title":"Generative Adversarial Net（GAN）","slug":"生成对抗网络（GAN）","date":"2018-04-18T02:56:01.000Z","updated":"2018-04-18T08:06:25.000Z","comments":true,"path":"2018/04/18/生成对抗网络（GAN）/","link":"","permalink":"http://kayleman.github.io/2018/04/18/生成对抗网络（GAN）/","excerpt":"前言GAN（生成对抗网络）最早是由2014年NIPS的一篇文章：Generative Adversarial Net 所提出来的，是近几年来深度学习领域比较热门的一块。简单来说，GAN的主要思想就是一种二人零和博弈的思想（two-player game）。本文旨在浅显地理解传统的GAN，分享一下学习心得。","text":"前言GAN（生成对抗网络）最早是由2014年NIPS的一篇文章：Generative Adversarial Net 所提出来的，是近几年来深度学习领域比较热门的一块。简单来说，GAN的主要思想就是一种二人零和博弈的思想（two-player game）。本文旨在浅显地理解传统的GAN，分享一下学习心得。 什么是GAN？前面有提到了GAN其实就是一个博弈论中的二人零和博弈的思想，在GAN模型中博弈的双方分别是生成模型（generative model）和判别模型（discriminative）。生成模型和判别模型都类似于一个黑匣子，接受一个输入然后有一个输出。不同点在于生成模型G是从潜在空间（latent space）中随机采样作为输入，然后输出一个尽量与训练集中的真实样本接近的结果。判别模型D的输入则为真实样本或生成模型的输出，它的目的是将生成模型的输出从真实样本中尽可能地分别出来。判别模型是一个二分类器，判别一个样本来自于训练数据而不是生成模型生成的数据的概率。 打个比方说：生成模型G就好像一个假币制造团伙，专门制造假币来欺骗警察。判别模型D就好比是警察，拥有火眼金睛专门检测收到的是真币还是假币。生成模型也就是假币制造团伙的目的是生成（制造）出可以以假乱真的假币，使得判别模型(警察)无法辨别真伪。而判别模型（警察）的目标是想方设法地去检测出来生成模型（假币制造团伙）生成（制造）的假币。 简单地理解了GAN的构成之后，来看看结合实际用例。如下图所示，生成一个新的脸的模型： 我们首先要想清楚在使用GAN的时候的两个问题： 我们有什么？比如上面的这个图，我们有的只是真实采集而来的人脸样本数据集，仅此而已，而且很关键的一点是我们连人脸数据集的类标签都没有，也就是我们不知道那个人脸对应的是谁。 我们要得到什么至于要得到什么，不同的任务得到的东西不一样，我们只说最原始的GAN目的，那就是我们想通过输入一个噪声，模拟得到一个人脸图像，这个图像可以非常逼真以至于以假乱真。 再来理解下GAN的两个模型要做什么。首先判别模型，就是图中右半部分的网络，直观来看就是一个简单的神经网络结构，输入就是一副图像，输出就是一个概率值，用于判断真假使用（概率值大于0.5那就是真，小于0.5那就是假），真假也不过是人们定义的概率而已。其次是生成模型，生成模型要做什么呢，同样也可以看成是一个神经网络模型，输入是一组随机数Z，输出是一个图像，不再是一个数值而已。从图中可以看到，会存在两个数据集，一个是真实数据集，这好说。另一个是假的数据集，这个数据集就是由生成网络造（生成）出来的数据集。根据这个图我们再来理解一下GAN的目标是要干什么： 生成网络的目的：生成网络是造样本的，它的目的就是使得自己生成样本的能力尽可能强，强到什么程度呢，你判别网络没法判断我是真样本还是假样本。 判别网络的目的：就是能判别出来输入的一张图它是来自真实样本集还是假样本集。假如输入的是真样本，网络输出就接近1，输入的是假样本，网络输出接近0，那么很完美，达到了很好判别的目的。 有了这个理解我们再来看看为什么叫做对抗网络了。判别网络说，我很强，来一个样本我就知道它是来自真样本集还是假样本集。生成网络就不服了，说我也很强，我生成一个假样本，虽然我生成网络知道是假的，但是你判别网络不知道呀，我包装的非常逼真，以至于判别网络无法判断真假。那么用输出数值来解释就是，生成网络生成的假样本进去了判别网络以后，判别网络给出的结果是一个接近0.5的值，极限情况就是0.5，也就是说判别不出来了，这就是纳什平衡了。 由这个分析可以发现，生成网络与判别网络的目的正好是相反的，一个说我能判别的好，一个说我让你判别不好。所以叫做对抗，叫做博弈。那么最后的结果到底是谁赢呢？这就要归结到设计者，也就是我们希望谁赢了。作为设计者的我们，我们的目的是要得到以假乱真的样本，那么很自然的我们希望生成样本赢了，也就是希望生成样本很真，判别网络能力不足以区分真假样本。 如何训练GAN？知道了GAN大概的目的与设计思路，那么一个很自然的问题来了就是我们该如何用数学方法解决这么一个对抗问题。这就涉及到如何训练这样一个生成对抗网络模型了，还是先上一个图，用图来解释最直接： 需要注意的是生成模型与对抗模型可以说是完全独立的两个模型，好比就是完全独立的两个神经网络模型，他们之间没有什么联系。 那么训练这样的两个模型的大方法就是：单独交替迭代训练。 什么意思？因为是2个网络，不好一起训练，所以才去交替迭代训练，我们一一来看。 假设现在生成网络模型已经有了（当然可能不是最好的生成网络），那么给一堆随机数组，就会得到一堆假的样本集（因为不是最终的生成模型，那么现在生成网络可能就处于劣势，导致生成的样本就不咋地，可能很容易就被判别网络判别出来了说这货是假冒的），但是先不管这个，假设我们现在有了这样的假样本集，真样本集一直都有，现在我们人为的定义真假样本集的标签，因为我们希望真样本集的输出尽可能为1，假样本集为0，很明显这里我们就已经默认真样本集所有的类标签都为1，而假样本集的所有类标签都为0. 有人会说，在真样本集里面的人脸中，可能张三人脸和李四人脸不一样呀，对于这个问题我们需要理解的是，我们现在的任务是什么，我们是想分样本真假，而不是分真样本中那个是张三label、那个是李四label。况且我们也知道，原始真样本的label我们是不知道的。回过头来，我们现在有了真样本集以及它们的label（都是1）、假样本集以及它们的label（都是0），这样单就判别网络来说，此时问题就变成了一个再简单不过的有监督的二分类问题了，直接送到神经网络模型中训练就完事了。假设训练完了，下面我们来看生成网络。 对于生成网络，想想我们的目的，是生成尽可能逼真的样本。那么原始的生成网络生成的样本你怎么知道它真不真呢？就是送到判别网络中，所以在训练生成网络的时候，我们需要联合判别网络一起才能达到训练的目的。什么意思？就是如果我们单单只用生成网络，那么想想我们怎么去训练？误差来源在哪里？细想一下没有，但是如果我们把刚才的判别网络串接在生成网络的后面，这样我们就知道真假了，也就有了误差了。所以对于生成网络的训练其实是对生成-判别网络串接的训练，就像图中显示的那样。那么现在来分析一下样本，原始的噪声数组Z我们有，也就是生成了假样本我们有，此时很关键的一点来了，我们要把这些假样本的标签都设置为1，也就是认为这些假样本在生成网络训练的时候是真样本。那么为什么要这样呢？我们想想，是不是这样才能起到迷惑判别器的目的，也才能使得生成的假样本逐渐逼近为正样本。重新顺一下思路，现在对于生成网络的训练，我们有了样本集（只有假样本集，没有真样本集），有了对应的label（全为1），是不是就可以训练了？有人会问，这样只有一类样本，训练啥呀？谁说一类样本就不能训练了？只要有误差就行。还有人说，你这样一训练，判别网络的网络参数不是也跟着变吗？没错，这很关键，所以在训练这个串接的网络的时候，一个很重要的操作就是不要判别网络的参数发生变化，也就是不让它参数发生更新，只是把误差一直传，传到生成网络那块后更新生成网络的参数。这样就完成了生成网络的训练了。 在完成生成网络训练后，那么我们是不是可以根据目前新的生成网络再对先前的那些噪声Z生成新的假样本了，没错，并且训练后的假样本应该是更真了才对。然后又有了新的真假样本集（其实是新的假样本集），这样又可以重复上述过程了。我们把这个过程称作为单独交替训练。我们可以实现定义一个迭代次数，交替迭代到一定次数后停止即可。这个时候我们再去看一看噪声Z生成的假样本会发现，原来它已经很真了。 看完了这个过程是不是感觉GAN的设计真的很巧妙，个人觉得最值得称赞的地方可能在于这种假样本在训练过程中的真假变换，这也是博弈得以进行的关键之处。 数学公式描述文字的描述相信已经让大多数的人知道了这个过程，下面我们来看看原文中几个重要的数学公式描述，首先我们直接上原始论文中的目标公式吧： 上述这个公式说白了就是一个最大最小优化问题，其实对应的也就是上述的两个优化过程。有人说如果不看别的，能达看到这个公式就拍案叫绝的地步，那就是机器学习的顶级专家，同时也说明这个简单的公式意义重大。 这个公式既然是最大最小的优化，那就不是一步完成的，其实对比我们的分析过程也是这样的，这里先优化D，然后再去优化G，本质上是两个优化问题，把它拆解就如同下面两个公式： 优化D： 优化G： 可以看到，优化D的时候，也就是判别网络，其实没有生成网络什么事，后面的G(z)这里就相当于已经得到的假样本。优化D的公式的第一项，使的真样本x输入的时候，得到的结果越大越好，可以理解，因为需要真样本的预测结果越接近于1越好嘛。对于假样本，需要优化是的其结果越小越好，也就是D(G(z))越小越好，因为它的标签为0。但是呢第一项是越大，第二项是越小，这不矛盾了，所以呢把第二项改成1-D(G(z))，这样就是越大越好，两者合起来就是越大越好。 那么同样在优化G的时候，这个时候没有真样本什么事，所以把第一项直接却掉了。这个时候只有假样本，但是我们说这个时候是希望假样本的标签是1的，所以是D(G(z))越大越好，但是呢为了统一成1-D(G(z))的形式，那么只能是最小化1-D(G(z))，本质上没有区别，只是为了形式的统一。之后这两个优化模型可以合并起来写，就变成了最开始的那个最大最小目标函数了。 所以回过头来我们来看这个最大最小目标函数，里面包含了判别模型的优化，包含了生成模型的以假乱真的优化，完美的阐释了这样一个优美的理论。 GAN的强大之处有人说GAN强大之处在于可以自动的学习原始真实样本集的数据分布，不管这个分布多么的复杂，只要训练的足够好就可以学出来。针对这一点，感觉有必要好好理解一下为什么别人会这么说。 我们知道，传统的机器学习方法，我们一般都会定义一个什么模型让数据去学习。比如说假设我们知道原始数据属于高斯分布呀，只是不知道高斯分布的参数，这个时候我们定义高斯分布，然后利用数据去学习高斯分布的参数得到我们最终的模型。再比如说我们定义一个分类器，比如SVM，然后强行让数据进行东变西变，进行各种高维映射，最后可以变成一个简单的分布，SVM可以很轻易的进行二分类分开，其实SVM已经放松了这种映射关系了，但是也是给了一个模型，这个模型就是核映射（什么径向基函数等等），说白了其实也好像是你事先知道让数据该怎么映射一样，只是核映射的参数可以学习罢了。所有的这些方法都在直接或者间接的告诉数据你该怎么映射一样，只是不同的映射方法能力不一样。那么我们再来看看GAN，生成模型最后可以通过噪声生成一个完整的真实数据（比如人脸），说明生成模型已经掌握了从随机噪声到人脸数据的分布规律了，有了这个规律，想生成人脸还不容易。然而这个规律我们开始知道吗？显然不知道，如果让你说从随机噪声到人脸应该服从什么分布，你不可能知道。这是一层层映射之后组合起来的非常复杂的分布映射规律。然而GAN的机制可以学习到，也就是说GAN学习到了真实样本集的数据分布。 再拿原论文中的一张图来解释： 这张图表明的是GAN的生成网络如何一步步从均匀分布学习到正太分布的。原始数据x服从正太分布，这个过程你也没告诉生成网络说你得用正太分布来学习，但是生成网络学习到了。假设你改一下x的分布，不管什么分布，生成网络可能也能学到。这就是GAN可以自动学习真实数据的分布的强大之处。 还有人说GAN强大之处在于可以自动的定义潜在损失函数。 什么意思呢，这应该说的是判别网络可以自动学习到一个好的判别方法，其实就是等效的理解为可以学习到好的损失函数，来比较好或者不好的判别出来结果。虽然大的loss函数还是我们人为定义的，基本上对于多数GAN也都这么定义就可以了，但是判别网络潜在学习到的损失函数隐藏在网络之中，不同的问题这个函数就不一样，所以说可以自动学习这个潜在的损失函数。 最后现在的GAN已经到了五花八门的时候了，各种GAN应用也很多，理解底层原理再慢慢往上层扩展。GAN还是一个很厉害的东西，它使得现有问题从有监督学习慢慢过渡到无监督学习，而无监督学习才是自然界中普遍存在的，因为很多时候没有办法拿到监督信息的。要不Yann Lecun 赞叹GAN是机器学习近十年来最有意思的想法。","categories":[{"name":"论文笔记","slug":"论文笔记","permalink":"http://kayleman.github.io/categories/论文笔记/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"http://kayleman.github.io/tags/深度学习/"}]},{"title":"Python2到Python3代码的转换工具2to3.py","slug":"Python2到Python3代码的转换工具2to3.py","date":"2017-10-27T08:40:12.000Z","updated":"2017-10-27T08:43:07.000Z","comments":true,"path":"2017/10/27/Python2到Python3代码的转换工具2to3.py/","link":"","permalink":"http://kayleman.github.io/2017/10/27/Python2到Python3代码的转换工具2to3.py/","excerpt":"前言经常会遇到需要将Python2代码转换成Python3的情况.如果只是简单的改改print,那么直接手动改就行了,但是如果有很多地方需要修改就比较令人头疼.最近才知道Python官方就已经准备了一个转换工具:2to3.py 注:在Windows环境下","text":"前言经常会遇到需要将Python2代码转换成Python3的情况.如果只是简单的改改print,那么直接手动改就行了,但是如果有很多地方需要修改就比较令人头疼.最近才知道Python官方就已经准备了一个转换工具:2to3.py 注:在Windows环境下 所在位置无论你的Python是官网下载安装的还是Anaconda中带的.都可以在{Python_HOME}\\Tools\\scripts里面找到2to3.py 操作过程比如说我有一个Python2的.py文件需要修改,路径为:G:\\Code\\OSVOS-TensorFlow\\osvos.py 首先在终端进入到2to3.py这个文件所在的文件夹.也就是{Python_HOME}\\Tools\\scripts,我这里的Python是Anaconda3里的,所以我的路径是G:\\Anaconda3\\Tools\\scripts 输入python 2to3.py -w G:\\Code\\OSVOS-TensorFlow\\osvos.py-w这个参数是为了直接生成一个新的osvos.py文件代替我原来的osvos.py文件,同时会把原来的osvos.py文件加一个.bak后缀备份.于是目录下会多了一个osvos.py.bak文件,如果不想生成.bak文件,在运行的时候加上-n即可.如果不想看那一堆输出内容,加上-no-diffs即可. 如果要了解更多参数的使用方法,可以直接输入:python 2to3.py -h","categories":[{"name":"备忘","slug":"备忘","permalink":"http://kayleman.github.io/categories/备忘/"}],"tags":[{"name":"python","slug":"python","permalink":"http://kayleman.github.io/tags/python/"}]},{"title":"Java和python的代码命名大小写规范","slug":"代码命名大小写规范","date":"2017-09-07T02:31:40.000Z","updated":"2017-09-07T02:55:20.000Z","comments":true,"path":"2017/09/07/代码命名大小写规范/","link":"","permalink":"http://kayleman.github.io/2017/09/07/代码命名大小写规范/","excerpt":"前言代码命名这种利人利己的事情,还是要好好改正学习一下的.找了一篇比较简洁明了的博客,并修改了一些错误,记录一下备忘.最后再附上一个函数命名查询的网站.可直接输入中文查询.妈妈再也不用担心我想不出函数名啦.","text":"前言代码命名这种利人利己的事情,还是要好好改正学习一下的.找了一篇比较简洁明了的博客,并修改了一些错误,记录一下备忘.最后再附上一个函数命名查询的网站.可直接输入中文查询.妈妈再也不用担心我想不出函数名啦. Java命名规范 项目名称：全部小写 常量：都用大写。如：public static final String DBDRIVER = “…..”; 类名：大写开头： 如：public class Person{} 属性名：小写：如：String personName = “Kayle”; 方法名：小写：如：public String getPersonName() {return this.personName} 构造函数名：与类名称一样，所以也是大写开头。 包名：所有的单词都是小写：如：import java.io.* Python命名规范 模块名：小写字母，单词之间用_分割 如：rivet_detection 包名：小写字母，单词之间用_分割 如：rivet_detection 类名：单词首字母大写 如：python class LogRecord(object): 普通变量：小写字母，单词之间用_分割 如：exc_info 实例变量：以_开头，小写字母，单词之间用_分割 如:_exc_info，以一个下划线开头的标识符(_xxx)，不能访问的类属性，但可通过类提供的接口进行访问，不会被语句 “from module import *” 语句加载 私有实例变量：以__开头（2个下划线），小写字母，单词之间用_分割 如:__private_var ，外部访问会报错 专有变量：__开头（2个下划线），__结尾（2个下划线），一般为python的自有变量，不要以这种方式命名 如:__doc__ ，是系统定义的，具有特殊意义的标识符 普通函数：小写字母，单词之间用_分割： 如:get_name() 私有函数：以__开头（2个下划线），小写字母，单词之间用分割 如:__get_name() ，外部访问会报错. 函数命名查询网站http://unbug.github.io/codelf/ 参考http://blog.csdn.net/quiet_girl/article/details/73896791","categories":[{"name":"备忘","slug":"备忘","permalink":"http://kayleman.github.io/categories/备忘/"}],"tags":[{"name":"python","slug":"python","permalink":"http://kayleman.github.io/tags/python/"},{"name":"Java","slug":"Java","permalink":"http://kayleman.github.io/tags/Java/"}]},{"title":"修改Windows命令界面字体","slug":"修改Windows命令界面字体","date":"2017-08-08T10:26:59.000Z","updated":"2017-08-08T10:30:01.000Z","comments":true,"path":"2017/08/08/修改Windows命令界面字体/","link":"","permalink":"http://kayleman.github.io/2017/08/08/修改Windows命令界面字体/","excerpt":"前言平时在使用Windows的时候经常会用到命令界面，但是Windows命令界面所用的默认字体真的是看着很不舒服，于是就去找了一下修改Windows命令界面字体的方法。","text":"前言平时在使用Windows的时候经常会用到命令界面，但是Windows命令界面所用的默认字体真的是看着很不舒服，于是就去找了一下修改Windows命令界面字体的方法。 默认情况在默认的情况下，命令界面的显示效果如下图所示： 这个字体让我看着很不舒服，在窗口的顶端边栏右键，在弹出的菜单中选择属性，可以看到以下所示的属性： 当前的代码页是936： 字体选项界面显示的是： 可以看到默认的只有两种字体可以选择，并且同样都是看着不舒服的字体。 修改默认字体我们可以打开注册表看看，打开注册表定位到HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Console\\TrueTypeFont就可以看到Windows下的其它字体。 其中的000和0000是我后来自己添加进去的，其它都是默认存在的字体。我们可以看到有Consolas字体，这个字体看着还是挺舒服的。0和00两项都是代码页437页可用的字体，可以在命令界面输入chcp [codepage]来进行切换，例如下图就是输入chcp 437后得到的结果。如图： 现在可以再来看一下属性页面，当前代码页和可选字体都已经发生了改变。 现在的当前代码页是437： 可选择字体多出了Consolas和Lucida Console，还有一个Bitstream Vera Sans Mono字体是我在注册表添加了一个值所多出来的。 我们可以看一下选择了Consolas之后的效果： 看着感觉还不错，如果你还想要用别的字体的话，就需要在注册表中添加命令行程序可用的字体了。首先按上面的步骤打开注册表，增加一项名字为000的字符串值，并将其值设置为你想要用的字体的名字（当然这个字体是要你的系统字体中有的，我专门下载了Mac OS上的专有字体Monaco想进行更换，但是并没有出现这个字体选项，可能不属于系统自带的字体吧。），可以看到我增加了一个名为Bitstream Vera Sans Mono的字体，可以看到效果图如下： 参考http://www.cnblogs.com/kangflict/p/4111010.html","categories":[{"name":"备忘","slug":"备忘","permalink":"http://kayleman.github.io/categories/备忘/"}],"tags":[{"name":"Windows7","slug":"Windows7","permalink":"http://kayleman.github.io/tags/Windows7/"}]},{"title":"如何将iPhone/iPad备份到外置硬盘中","slug":"如何将iPhone备份到外置硬盘中","date":"2017-07-20T10:05:18.000Z","updated":"2017-08-08T07:50:37.000Z","comments":true,"path":"2017/07/20/如何将iPhone备份到外置硬盘中/","link":"","permalink":"http://kayleman.github.io/2017/07/20/如何将iPhone备份到外置硬盘中/","excerpt":"前言因为偶然发现在Web上登录iCloud使用”查找我的iPhone”功能不需要进行二次验证, 可以直接登录, 并且能够锁定自己的设备, 甚至还能够直接抹除设备上的数据, 为了避免在密码泄露的时候被不怀好意的人抹除数据造成损失, 于是决定将iPhone的数据备份. 很多人可能都只是用iCloud进行数据的备份, 但是iCloud免费空间太小不说, 而且备份极其不稳定, 经常不能成功备份. 它所显示的备份成功, 其实有时候并没有真正地备份成功. 有次在恢复备份数据的时候才发现没有备份成功, 导致很多数据丢失. 所以, 我选择了稳定的iTunes进行备份. 但是有一个问题, iTunes默认情况下只能备份到内置磁盘, 而Mac的存储空间通常比较紧张, 所以就考虑把备份放到移动硬盘上. 我使用的是手动修改备份路径的方法.","text":"前言因为偶然发现在Web上登录iCloud使用”查找我的iPhone”功能不需要进行二次验证, 可以直接登录, 并且能够锁定自己的设备, 甚至还能够直接抹除设备上的数据, 为了避免在密码泄露的时候被不怀好意的人抹除数据造成损失, 于是决定将iPhone的数据备份. 很多人可能都只是用iCloud进行数据的备份, 但是iCloud免费空间太小不说, 而且备份极其不稳定, 经常不能成功备份. 它所显示的备份成功, 其实有时候并没有真正地备份成功. 有次在恢复备份数据的时候才发现没有备份成功, 导致很多数据丢失. 所以, 我选择了稳定的iTunes进行备份. 但是有一个问题, iTunes默认情况下只能备份到内置磁盘, 而Mac的存储空间通常比较紧张, 所以就考虑把备份放到移动硬盘上. 我使用的是手动修改备份路径的方法. 迁移旧的备份文件 退出iTunes, 连接你的外置硬盘. 打开Finder, 按下 Command + Shift + G快捷键前往文件夹, 在弹出的窗口中输入以下路径(iTunes的默认备份路径):~/Library/Application Support/MobileSync/ 将整个Backup拷贝到外置硬盘中(我的外置硬盘名字叫MacBackup, 并且在里面新建了个文件夹, 名字叫做iPhoneBackup, 所以我是拷贝到这个iPhoneBackup文件夹中, 你可以根据自己的情况对应地修改下文中命令中的路径名称). 拷贝完之后, 需要将这个Backup文件夹重命名为其他名字, 或者直接把这个文件夹给删除. 因为如果不这样做, 后面在进行软连接的时候, 会出现文件夹已存在的错误.如下图: 创建符号链接为了让iTunes能够备份到外置硬盘, 关键是在原备份文件夹和外置文件夹之间建立符号链接(Symbolic Link, 也称软链接, 类似于Windows的快捷方式和OSX中的替身文件). 从而使得我们能够欺骗iTunes, 让它误以为是备份在了内置硬盘上. 打开Finder, 选中外置硬盘中的iPhoneBackup文件夹. 打开终端, 将iPhoneBackup文件夹拖入终端, 得到一个路径:/Volumes/MacBackup/iPhoneBackup 复制这个路径, 和iTunes的默认备份路径一起, 组合成下面的命令(不要落掉斜杠和空格,建议直接复制):ln -s /Volumes/MacBackup/iPhoneBackup/Backup ~/Library/Application\\ Support/MobileSync/ 重启终端, 执行第3步中的命令. 完成后, 查看iTunes默认备份文件夹, 发现一个带着小箭头的Backup文件夹, 表明软链接建立完成. 备份打开iTunes, 选择备份到本电脑, 立即备份即可自动备份到外置硬盘. 参考https://sspai.com/post/33524","categories":[{"name":"备忘","slug":"备忘","permalink":"http://kayleman.github.io/categories/备忘/"}],"tags":[{"name":"教程","slug":"教程","permalink":"http://kayleman.github.io/tags/教程/"}]},{"title":"利用Github Pages + Hexo搭建自己的博客","slug":"利用Github Pages + Hexo搭建自己的博客","date":"2017-06-29T08:28:38.000Z","updated":"2018-04-18T03:02:41.000Z","comments":true,"path":"2017/06/29/利用Github Pages + Hexo搭建自己的博客/","link":"","permalink":"http://kayleman.github.io/2017/06/29/利用Github Pages + Hexo搭建自己的博客/","excerpt":"前言一直想要搭建一个自己的博客，用来记录自己的学习到的一些东西，方便以后忘记了来翻看。那么就用本文记录一下在搭建博客过程中遇到的一些坑。 首先要说明本文是在Mac环境下搭建的，Windows环境下面没有尝试，但是根据Wiyee同学说的都是大同小异罢了。 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。","text":"前言一直想要搭建一个自己的博客，用来记录自己的学习到的一些东西，方便以后忘记了来翻看。那么就用本文记录一下在搭建博客过程中遇到的一些坑。 首先要说明本文是在Mac环境下搭建的，Windows环境下面没有尝试，但是根据Wiyee同学说的都是大同小异罢了。 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 1.Github PagesGithub Pages 是面向用户、组织和项目开放的公共静态页面搭建托管服务，站点可以被免费托管在Github 上，你可以选择使用Github Pages 默认提供的域名github.io 或者自定义域名来发布站点。 创建Github Pages的前提是你有一个Github帐号就行了，然后利用这个帐号创建一个仓库，但是这个仓库是有规则的，其格式必须为：yourusername.github.io。其中yourusername是你的Github用户名，比如说我的用户名是kayleman，所以我的仓库格式是kayleman.github.io。 没有Github的朋友可以点击这里进行注册。 登陆Github后可以在右边栏点击New repository创建一个新的仓库。如下图： 在Repository name的位置输入你的仓库名，如下图： 这里是因为我拿自己的仓库名做示范，而仓库名是必须要唯一的，所以才会提示仓库名已存在，接下来点击Create repository就行了。 2.环境准备和搭建安装Hexo的过程很简单，但是在安装前必须要确定你的电脑是否有以下程序： Node.js Git 如果没有的话就需要依次进行安装。 Git具体的配置可以上网搜一下，这里不再赘述。 安装Node.js到Node.js官网去下载相应平台的最新版本安装即可 安装Git使用 Homebrew，在终端输入brew install git进行安装 安装Hexo在终端输入npm install -g hexo-cli 更详细的可以见Hexo的官方文档。 建站Hexo安装好了之后，就可以开始建站了，通过终端cd到将要建站的位置，输入以下命令： 123hexo init yournamecd yournamenpm install 其中yourname可以任意取，比如我的叫Hexo， 关于建站的更多信息你可以参考官方文档，点击这里。 官方文档没有讲解如何配置与Github Pages进行关联，在此简单说明一下。进入到你的站点，也就是yourname文件夹，下文统一使用我自己的文件夹名Hexo方便描述。进入到文件夹以后你可以看到_config.yml这个文件，这是一个配置文件，是用来配置信息的。用编辑器打开_config.yml拉到最下面，你可以看到有deply和type字段，可以参考我的例子如下输入： 1234deploy: type: git repo: https://github.com/Kayleman/Kayleman.github.io.git branch: master 其中repo：后面的就改成你的Github Pages提交代码的git地址。 你的git地址在你刚才创建好的Github Pages仓库就能找到。 到此为止，你可以进入你的站点文件夹，使用hexo s命令，如果你看到Hexo is running at http://localhost:4000/. Press Ctrl+C to stop这么一句话，那么请打开你的浏览器输入http://localhost:4000/你就可以看到最初始的hexo界面了，是不是有点丑？不要紧，后期我们还可以修改页面的主题来更换样式。 发布刚才那样只是能够在本地显示，还没有上传到Github Pages服务器上面，所以我们需要在站点里输入以下命令： 123hexo cleanhexo ghexo d 其中第一条命令是清楚缓存，第二条命令全名是hexo generate，是用来生成静态文件的，第三条命令全名是hexo deploy，这条命令是用来把本地的文件发布到Github Pages上的。一般平时就使用这几个命令，更多命令可以参考官方文档 在我刚开始使用hexo d部署的时候出现了not found的问题，如果遇到了这个问题，请先输入： 1npm install hexo-deployer-git --save 然后再运行hexo d进行尝试。 为了方便hexo g和hexo d可以组合起来写，如下： 1hexo d -g 写文章写文章可以使用命令界面输入命令来完成，但是我觉得有点繁琐也不利于排版，于是就没用使用这种方法。由于最终上传的是.md文件，是markdown文件，关于markdown的一些简单语法你可以上网查阅一下，还是挺简单的。(我本人在Windows系统下使用MarkdownPad 2来编辑md文件，在Mac系统下是用MacDown，都挺好用) 在我们写好文章之后，可以直接把.md文件放到Hexo/source/_post目录下，再发布到Github Pages上你就可以看到文章了，稍微有那么一会的延迟，如果你没有绑定域名的话，在浏览器输入你的仓库地址，比如我的是kayleman.github.io就可以看到你的博客页面了。 还有一点就是在编辑文章的时候，可以在适当位置添加以下代码： 1&lt;!-- more --&gt; more以上是文章的摘要，在主页显示，more以下需要点击read more链接才能打开全文显示，可以有效避免博客主页被过多地占用。例如我的博客效果如下： Hexo主题的更换前面已经看到了，初始化的页面是非常丑的，我们可以更换Hexo的主题，在知乎上有这个话题，可以点击这里去参考一下。找到喜欢的主题后安装主题就是一条命令，比如我使用的是icarus主题 1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 从git上clone下来放到Hexo/theme路径下。然后打开Hexo/_config.yml文件，修改里面theme的参数为icarus。 之后再根据主题作者Github上提供的方法一步步配置icarus文件夹里面的_config.yml文件。 至于具体的主题配置和一些模块的设置我会再详细地写一篇博客，这里不再赘述。 域名绑定要绑定域名，首先你要去注册一个域名，我是在万网注册的，你可以点击这里进行注册，或者去其它的域名注册商那注册。对于域名的具体购买等步骤这里也不再赘述。 这里需要提一下的就是注册的域名如何与Github Pages进行绑定。首先在本地站点也就是Hexo目录下的source下面添加一个CNAME文件，不带后缀，效果如下： 用文本编辑器打开，里面添加你的域名信息，不加http://，如下图： 在万网的域名控制中心，点击解析，然后添加解析，详细的方法可以见域名注册商的网站，万网的方法点击这里。 参考https://hexo.io/zh-cn/docs/index.html http://ibruce.info/2013/11/22/hexo-your-blog/ http://www.jianshu.com/p/834d7cc0668d","categories":[{"name":"备忘","slug":"备忘","permalink":"http://kayleman.github.io/categories/备忘/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://kayleman.github.io/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"http://kayleman.github.io/tags/博客/"}]},{"title":"Win7遇到的小问题备忘","slug":"win7自己遇到的小问题总结","date":"2017-06-23T05:25:21.000Z","updated":"2017-06-29T08:51:52.000Z","comments":true,"path":"2017/06/23/win7自己遇到的小问题总结/","link":"","permalink":"http://kayleman.github.io/2017/06/23/win7自己遇到的小问题总结/","excerpt":"前言本文记录了我自己在使用win7过程中遇到的一些小问题,整理起来备忘.","text":"前言本文记录了我自己在使用win7过程中遇到的一些小问题,整理起来备忘. 1.开机自动默认打开numlock键，想要关闭。 在开始菜单搜索栏输入 regedit ，打开注册表定位到下面键值HKEY_USERS\\.DEFAULT\\Control Panel\\Keyboard 修改InitialKeyboardIndicators的键值 设置为“2”，小键盘默认为开； 设置为“1”，小键盘默认为关闭； 设置为“0”，则系统关机前Unm Lock是什么状态，开机后还是什么状态。 2.win7系统开机，还没输密码直接显示用户密码错误。 在开始菜单搜索框输入 “netplwiz” 按回车，打开高级用户控制面板； 在高级用户控制面板中，“要使用本机，用户需输入用户名和密码(E)”项的勾选打勾. 3.开机界面什么都没有 Ctrl + Shift + Esc调出任务管理器,直接把explorer进程给关闭 在任务管理器左上角选择”文件” –&gt; “新建任务” 输入explorer以管理员身份运行。 4.怎么上Google 用GoGoTester找可用的Google IP 在cmd界面ping一下IP是否可用，确认可用 到C:\\Windows\\System32\\drivers\\etc修改hosts 最好刷新一下dns，即在cmd界面输入ipconfig/flushdns 或者直接去www.laod.cn这个网站上去找hosts文件,下载下来,同样按照第3步替换hosts文件 5.怎么不让Google跳转到hk或者其它地区第一次直接在浏览器打www.google.com的时候经常会出现无法连接的情况 可以直接输入https://www.google.com 然后有可能会被跳转到.hk的香港的服务器去,由于香港的服务器也是被屏蔽了很多信息的 如果不想跳转可以一次性直接输入https://www.google.com/ncr 后面的/ncr代表禁止国别跳转 之后就不需要在次输入/ncr会默认不跳转 6.怎么在chrome搜索框默认用Google搜索而不跳转到hk 在Google界面随便搜索一个词比如说“asd” 把地址栏里的asd对应替换成%s，全部复制 到设置里添加搜索引擎 把这个新添加的设为默认搜索引擎 7.win7怎么设置定时关机 最简单的就用一些360，QQ管家，QQ音乐，WIFI共享精灵之类的 win7里面有自带的关机程序，在Windows\\System32\\Shutdown.exe，可以直接打开这个可执行应用程序 也可以选择“开始-&gt;运行-&gt;cmd”打开命令窗口，比如你的电脑要在22:00关机，输入“at 22:00 Shutdown -s” 到了22点电脑就会出现“系统关机”对话框，默认有30秒钟的倒计时并提示你保存工作。 如果你想以倒计时的方式关机，可以输入“Shutdown.exe -s -t 3600”，表示60分钟后自动关机，“3600”代表60分钟 设置好自动关机后，如果想取消的话，可以在运行中输入“shutdown -a”。 另外输入 “shutdown -i”，则可以打开设置自动关机对话框，对自动关机进行设置。 Shutdown.exe的参数，每个都具有特定的用途，执行每一个都会产生不同的效果，比如 -s：就表示关闭本地计算机 -a：表示取消关机操作 -f：强行关闭应用程序 -m 计算机名：控制远程计算机 -i：显示图形用户界面，但必须是Shutdown的第一个选项 -l：注销当前用户 -r：关机并重启 -t 时间：设置关机倒计时 -c “消息内容”：输入关机对话框中的消息内容 8.不格式化硬盘转换硬盘格式（FAT32转NTFS） 运行输入cmd进入命令界面 输入convert c: /fs:ntfs（其中C就是指C盘，转哪个写哪个盘名） 9.音量控制图标不见了怎么办将explorer.exe重启,具体怎么重启见前面第3条 10.图片只显示缩略图怎么办 打开我的电脑 点开工具，选择文件夹选项 点击查看，把始终显示图标勾选去掉。","categories":[{"name":"备忘","slug":"备忘","permalink":"http://kayleman.github.io/categories/备忘/"}],"tags":[{"name":"Windows7","slug":"Windows7","permalink":"http://kayleman.github.io/tags/Windows7/"}]},{"title":"Ubuntu16.04虚拟机设置固定IP的方法","slug":"Ubuntu16.04虚拟机设置固定IP上网","date":"2017-06-23T05:25:20.000Z","updated":"2017-06-29T08:48:48.000Z","comments":true,"path":"2017/06/23/Ubuntu16.04虚拟机设置固定IP上网/","link":"","permalink":"http://kayleman.github.io/2017/06/23/Ubuntu16.04虚拟机设置固定IP上网/","excerpt":"前言由于经常需要直接在主机通过IP连接到虚拟机,所以上网搜了一些Ubuntu设置固定IP上网的方法,其中遇到了一些问题,参考了大神的博客内容,之后会列出原文链接,如果侵犯了您的权利,请与我联系删除,谢谢. 设置固定IP的方法很多，大家都知道虚拟机上网有三种模式：bridged、host-only和NAT， 其中NAT模式对应VMnet8虚拟网络，host-only模式对应VMnet1虚拟网络，bridged模式对应 VMnet0虚拟网络，都是由VMware虚拟机自动配置而生成的，不需要用户自行设置。VMnet8和VMnet1提供DHCP服务，VMnet0虚拟 网络则不提供。 当前环境:虚拟机版本:VMware WorkStation 12系统版本:Ubuntu 16.04","text":"前言由于经常需要直接在主机通过IP连接到虚拟机,所以上网搜了一些Ubuntu设置固定IP上网的方法,其中遇到了一些问题,参考了大神的博客内容,之后会列出原文链接,如果侵犯了您的权利,请与我联系删除,谢谢. 设置固定IP的方法很多，大家都知道虚拟机上网有三种模式：bridged、host-only和NAT， 其中NAT模式对应VMnet8虚拟网络，host-only模式对应VMnet1虚拟网络，bridged模式对应 VMnet0虚拟网络，都是由VMware虚拟机自动配置而生成的，不需要用户自行设置。VMnet8和VMnet1提供DHCP服务，VMnet0虚拟 网络则不提供。 当前环境:虚拟机版本:VMware WorkStation 12系统版本:Ubuntu 16.04 1. 设置虚拟机上网方式为NAT在虚拟机设置中的网络适配器里,选择NAT模式 2. 配置VMnet8虚拟网络 在VMware的编辑选项中打开虚拟网络编辑器 按照下图中对虚拟网络进行设置,虚拟网络的列表里默认是有VMnet0,VMnet1和VMnet8三种,我只有一种是因为我把另外两种给移除了,在这里我们选择VMnet8网络,其中子网IP根据自己的情况进行设置,只要不把原来已有的给占用即可. 3. 进入到Ubuntu系统中配置网络主要配置下面三个方面的内容： 修改文件/etc/network/interfaces，这里是IP、网关、掩码等的一些配置； 修改文件/etc/resolv.conf，这个文件保存DNS的有关信息； 解决resolv.conf被重写问题； 重启虚拟机网络 (1).修改文件/etc/network/interfaces输入命令:1sudo vi /etc/network/interfaces 或者: 1sudo gedit /etc/network/interfaces 配置如下: 1234567891011#interfaces(5) file used by ifup(8) and ifdown(8)auto loiface lo inet loopbackauto ens33iface ens33 inet staticaddress 192.168.8.100netmask 255.255.255.0gateway 192.168.8.2dns-nameservers 8.8.8.8 其中较新版本的比如我的Ubuntu16.04 就是ens33,有的版本是eth0, 具体可以在终端输入ifconfig命令查看,如图: 另外其中的网关要和虚拟网络编辑器中设置的一致,一般好像为192.168.XXX.2 上面最后一行设置的DNS不是必要的,可在下一步设置,这一步的优先级比resolv.conf中高,会优先在这一步读取DNS,如果没有配置才会去resolve.conf里面查找. (2)修改文件/etc/resolv.conf输入命令: 1sudo vi /etc/resolv.conf 或 1sudo gedit /etc/resolv.conf 配置如下: 1nameserver 8.8.8.8 这里具体DNS因人而异 (3)解决resolv.conf被重写问题第二步中你虽然配置了DNS，但是每次重启虚拟机或重启网络后/etc/resolv.conf文件就会被重写，也就是又恢复原样了，你以前的配置就不存在了，每次都要手动配置是极不可取的，所以这步是必须的，首先我们要搞清楚resolv.conf被重写的原因和机制，这在不同 Ubuntu版本下有所差异。 在这一步,教程原文上有两种办法,第一种是根据不同系统版本来采取不同的办法,第二种是于版本无关,通用的做法.我选了第二种,如果想看第一种方法,可以在文末的原文链接里去看. 第二种办法就是在前面第(1)步中在最后面直接加上你的DNS地址,因为interfaces优先级比resolv.conf高,会优先看interfaces里面的DNS. (4)重启虚拟机网络配置完成后需要重启一下网络: 1sudo service networking restart 或者 1sudo /etc/init.d/networking restart 在这一步我重启网络失败了,只能选择了下面的重启网卡 12sudo ifconfig eth0 down sudo ifconfig eth0 up 赶紧试试是不是可以了 参考:原文链接","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://kayleman.github.io/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://kayleman.github.io/tags/Ubuntu/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://kayleman.github.io/tags/虚拟机/"}]},{"title":"Ubuntu虚拟机如何与主机共享科学上网","slug":"虚拟机里面的Ubuntu怎么和主机共享科学上网","date":"2017-06-23T05:25:17.000Z","updated":"2017-06-29T08:50:19.000Z","comments":true,"path":"2017/06/23/虚拟机里面的Ubuntu怎么和主机共享科学上网/","link":"","permalink":"http://kayleman.github.io/2017/06/23/虚拟机里面的Ubuntu怎么和主机共享科学上网/","excerpt":"前言主机已经科学上网了,希望虚拟机里面的Ubuntu也能够科学上网,要怎么做呢? 我用的科学上网软件是ShadowSocks,关于这个软件怎么科学上网网上有非常多的教程,这里就不够多介绍了","text":"前言主机已经科学上网了,希望虚拟机里面的Ubuntu也能够科学上网,要怎么做呢? 我用的科学上网软件是ShadowSocks,关于这个软件怎么科学上网网上有非常多的教程,这里就不够多介绍了 1.通过ShadowSocks科学上网通常这类软件里面都有允许来自局域网的连接之类的选项 勾选这个选项,然后查看一下代理端口是多少,一般默认是1080 2.查看主机的ip地址我主机是Windows系统,在命令窗口输入ipconfig,得到自己的主机ip 3.在Ubuntu下面填写代理在Ubuntu中打开Network,选择下面的Network proxy,选择Manual手动模式,将主机的IP和代理端口填入 完成!","categories":[{"name":"科学上网","slug":"科学上网","permalink":"http://kayleman.github.io/categories/科学上网/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://kayleman.github.io/tags/Ubuntu/"},{"name":"科学上网","slug":"科学上网","permalink":"http://kayleman.github.io/tags/科学上网/"}]},{"title":"Mac下Vim安装NERDTree插件的方法","slug":"Mac下Vim安装NERDTree插件","date":"2017-06-23T05:25:15.000Z","updated":"2017-06-29T08:49:30.000Z","comments":true,"path":"2017/06/23/Mac下Vim安装NERDTree插件/","link":"","permalink":"http://kayleman.github.io/2017/06/23/Mac下Vim安装NERDTree插件/","excerpt":"前言相信所有使用 vim 的同学都知道文件管理插件 NERDTree，这个几乎是所有拥护 vim 的开发人员都会使用的插件, 本文简单介绍了 NERDTree 的安装.","text":"前言相信所有使用 vim 的同学都知道文件管理插件 NERDTree，这个几乎是所有拥护 vim 的开发人员都会使用的插件, 本文简单介绍了 NERDTree 的安装. 1.安装pathogen.vim在Terminal输入以下命令,创建.vim文件夹和下面的autoload和bundle子文件夹,同时将pathogen.vim下载到autoload里面 12mkdir -p ~/.vim/autoload ~/.vim/bundle &amp;&amp; \\curl -LSso ~/.vim/autoload/pathogen.vim https://tpo.pe/pathogen.vim 通过vim ~/.vimrc编辑vim配置文件,将 1execute pathogen#infect() 添加到vimrc中 2.安装NERDTree进入到bundle文件夹,并且把NERDTree下载在这个目录下12cd ~/.vim/bundlegit clone https://github.com/scrooloose/nerdtree.git 在Terminal下输入vim进入vim窗口,输入:NERDTree启动NERDTree,在确定NERDTree已经安装成功后,为了避免以后每次开启都需要输入:NERDTree较为麻烦,为它设置一个快捷键 定义快捷键,键入vim ~/.vimrc按i进入插入模式输入nnoremap &lt;silent&gt; &lt;F5&gt; :NERDTree&lt;CR&gt;按Esc键返回Normal状态并输入:wq保存退出。定义F5为显示树状目录的快捷键。 参考http://jingyan.baidu.com/article/59a015e3a33404f7948865d2.htmlhttp://blog.chinaunix.net/uid-20032401-id-5706833.htmlhttps://github.com/johnbellone/vim","categories":[{"name":"Vim","slug":"Vim","permalink":"http://kayleman.github.io/categories/Vim/"}],"tags":[{"name":"Vim","slug":"Vim","permalink":"http://kayleman.github.io/tags/Vim/"},{"name":"插件","slug":"插件","permalink":"http://kayleman.github.io/tags/插件/"}]}]}